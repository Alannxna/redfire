# ğŸ—ï¸ RedFireå¤–éƒ¨å¾®æœåŠ¡æ¶æ„è®¾è®¡æ–‡æ¡£

## ğŸ“‹ è®¾è®¡æ¦‚è¿°

**è®¾è®¡ç›®æ ‡**: èˆå¼ƒå¤æ‚DDDæ¶æ„ï¼Œå»ºç«‹ç®€å•é«˜æ•ˆçš„å¤–éƒ¨å¾®æœåŠ¡æ¶æ„  
**æ ¸å¿ƒç†å¿µ**: Simple First + Service Oriented + Cloud Native  
**æ¶æ„æ¨¡å¼**: å¤–éƒ¨å¾®æœåŠ¡ + äº‹ä»¶é©±åŠ¨ + APIç½‘å…³  
**å®æ–½ç­–ç•¥**: æ¸è¿›å¼è¿ç§»ï¼Œé›¶åœæœºåˆ‡æ¢

---

## ğŸ¯ è®¾è®¡åŸåˆ™

### **1. Simple First (ç®€å•ä¼˜å…ˆ)**
- âŒ èˆå¼ƒDDDçš„å¤æ‚åˆ†å±‚æ¶æ„ (Domain/Application/Infrastructure)
- âŒ ç§»é™¤è¿‡åº¦æŠ½è±¡çš„CQRSæ¨¡å¼
- âŒ ç®€åŒ–ä¾èµ–æ³¨å…¥çš„å¤æ‚ç”Ÿå‘½å‘¨æœŸç®¡ç†
- âœ… é‡‡ç”¨ç›´æ¥çš„ä¸‰å±‚æ¶æ„: **API â†’ Service â†’ Repository**

### **2. Service Oriented (æœåŠ¡å¯¼å‘)**
- âœ… æŒ‰ä¸šåŠ¡åŠŸèƒ½åˆ’åˆ†ç‹¬ç«‹å¾®æœåŠ¡
- âœ… æœåŠ¡é—´é€šè¿‡æ ‡å‡†HTTP APIé€šä¿¡
- âœ… æ¯ä¸ªæœåŠ¡ç‹¬ç«‹éƒ¨ç½²å’Œæ‰©å±•
- âœ… æœåŠ¡å‘ç°å’Œè´Ÿè½½å‡è¡¡

### **3. Cloud Native (äº‘åŸç”Ÿ)**
- âœ… å®¹å™¨åŒ–éƒ¨ç½² (Docker + Kubernetes)
- âœ… æœåŠ¡ç½‘æ ¼æ¶æ„ (Istio)
- âœ… é…ç½®å¤–éƒ¨åŒ–ç®¡ç†
- âœ… å¯è§‚æµ‹æ€§æ”¯æŒ (Metrics + Logs + Tracing)

---

## ğŸ—ï¸ æ•´ä½“æ¶æ„è®¾è®¡

### **å¾®æœåŠ¡æ¶æ„å…¨æ™¯å›¾**

```mermaid
graph TB
    subgraph "å¤–éƒ¨å®¢æˆ·ç«¯"
        Web[Webå‰ç«¯]
        Mobile[ç§»åŠ¨ç«¯]
        API_Client[APIå®¢æˆ·ç«¯]
    end
    
    subgraph "APIç½‘å…³å±‚"
        Gateway[API Gateway]
        LB[è´Ÿè½½å‡è¡¡å™¨]
    end
    
    subgraph "æ ¸å¿ƒä¸šåŠ¡å¾®æœåŠ¡"
        UserSvc[ç”¨æˆ·æœåŠ¡]
        TradingSvc[äº¤æ˜“æœåŠ¡]
        StrategySvc[ç­–ç•¥æœåŠ¡]
        MarketSvc[è¡Œæƒ…æ•°æ®æœåŠ¡]
        RiskSvc[é£é™©ç®¡ç†æœåŠ¡]
        NotifySvc[é€šçŸ¥æœåŠ¡]
    end
    
    subgraph "åŸºç¡€è®¾æ–½å¾®æœåŠ¡"
        ConfigSvc[é…ç½®ç®¡ç†æœåŠ¡]
        AuthSvc[è®¤è¯æˆæƒæœåŠ¡]
        LogSvc[æ—¥å¿—æœåŠ¡]
        MonitorSvc[ç›‘æ§æœåŠ¡]
    end
    
    subgraph "å¤–éƒ¨é›†æˆæœåŠ¡"
        VnPySvc[VnPyå¼•æ“æœåŠ¡]
        DataSvc[å¤–éƒ¨æ•°æ®æœåŠ¡]
        PaymentSvc[æ”¯ä»˜æœåŠ¡]
    end
    
    subgraph "æ•°æ®å­˜å‚¨å±‚"
        DB[(æ•°æ®åº“é›†ç¾¤)]
        Cache[(Redisé›†ç¾¤)]
        MQ[(æ¶ˆæ¯é˜Ÿåˆ—)]
        Storage[(å¯¹è±¡å­˜å‚¨)]
    end
    
    Web --> Gateway
    Mobile --> Gateway
    API_Client --> Gateway
    
    Gateway --> UserSvc
    Gateway --> TradingSvc
    Gateway --> StrategySvc
    Gateway --> MarketSvc
    
    UserSvc --> DB
    TradingSvc --> DB
    StrategySvc --> DB
    MarketSvc --> Cache
    
    UserSvc --> AuthSvc
    TradingSvc --> RiskSvc
    StrategySvc --> VnPySvc
    MarketSvc --> DataSvc
    
    ConfigSvc --> DB
    AuthSvc --> Cache
    LogSvc --> Storage
    MonitorSvc --> DB
```

---

## ğŸ¯ æ ¸å¿ƒå¾®æœåŠ¡è¯¦ç»†è®¾è®¡

### **1. ç”¨æˆ·æœåŠ¡ (User Service)**

#### **èŒè´£èŒƒå›´**
- ç”¨æˆ·æ³¨å†Œã€ç™»å½•ã€è®¤è¯
- ç”¨æˆ·ä¿¡æ¯ç®¡ç†
- ç”¨æˆ·æƒé™æ§åˆ¶
- è´¦æˆ·çŠ¶æ€ç®¡ç†

#### **æŠ€æœ¯æ¶æ„**
```python
# ç®€åŒ–çš„ä¸‰å±‚æ¶æ„
ç”¨æˆ·æœåŠ¡/
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ auth_controller.py      # è®¤è¯æ§åˆ¶å™¨
â”‚   â”œâ”€â”€ user_controller.py      # ç”¨æˆ·æ§åˆ¶å™¨
â”‚   â””â”€â”€ profile_controller.py   # èµ„æ–™æ§åˆ¶å™¨
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ auth_service.py         # è®¤è¯æœåŠ¡
â”‚   â”œâ”€â”€ user_service.py         # ç”¨æˆ·æœåŠ¡
â”‚   â””â”€â”€ profile_service.py      # èµ„æ–™æœåŠ¡
â”œâ”€â”€ repositories/
â”‚   â”œâ”€â”€ user_repository.py      # ç”¨æˆ·ä»“å‚¨
â”‚   â””â”€â”€ session_repository.py   # ä¼šè¯ä»“å‚¨
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ user.py                 # ç”¨æˆ·æ¨¡å‹
â”‚   â””â”€â”€ session.py              # ä¼šè¯æ¨¡å‹
â””â”€â”€ config/
    â”œâ”€â”€ database.py             # æ•°æ®åº“é…ç½®
    â””â”€â”€ redis.py                # Redisé…ç½®
```

#### **æ ¸å¿ƒAPIæ¥å£**
```python
# api/auth_controller.py
from fastapi import APIRouter, Depends, HTTPException
from services.auth_service import AuthService

router = APIRouter(prefix="/auth", tags=["è®¤è¯"])

@router.post("/register")
async def register(
    user_data: UserRegisterRequest,
    auth_service: AuthService = Depends()
):
    """ç”¨æˆ·æ³¨å†Œ"""
    try:
        user = await auth_service.register(user_data)
        return {"success": True, "user_id": user.id}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/login")
async def login(
    credentials: LoginRequest,
    auth_service: AuthService = Depends()
):
    """ç”¨æˆ·ç™»å½•"""
    try:
        token = await auth_service.login(credentials)
        return {"access_token": token, "token_type": "bearer"}
    except Exception as e:
        raise HTTPException(status_code=401, detail="Invalid credentials")

@router.post("/logout")
async def logout(
    token: str = Depends(get_current_token),
    auth_service: AuthService = Depends()
):
    """ç”¨æˆ·ç™»å‡º"""
    await auth_service.logout(token)
    return {"success": True}
```

#### **ä¸šåŠ¡æœåŠ¡å®ç°**
```python
# services/auth_service.py
from typing import Optional
import bcrypt
import jwt
from datetime import datetime, timedelta

class AuthService:
    def __init__(self, user_repo: UserRepository, session_repo: SessionRepository):
        self.user_repo = user_repo
        self.session_repo = session_repo
        self.secret_key = "your-secret-key"
    
    async def register(self, user_data: UserRegisterRequest) -> User:
        """ç”¨æˆ·æ³¨å†Œ"""
        # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
        existing_user = await self.user_repo.get_by_email(user_data.email)
        if existing_user:
            raise ValueError("User already exists")
        
        # å¯†ç åŠ å¯†
        hashed_password = bcrypt.hashpw(
            user_data.password.encode(), bcrypt.gensalt()
        )
        
        # åˆ›å»ºç”¨æˆ·
        user = User(
            username=user_data.username,
            email=user_data.email,
            password_hash=hashed_password.decode(),
            is_active=True
        )
        
        return await self.user_repo.create(user)
    
    async def login(self, credentials: LoginRequest) -> str:
        """ç”¨æˆ·ç™»å½•"""
        # éªŒè¯ç”¨æˆ·
        user = await self.user_repo.get_by_email(credentials.email)
        if not user or not user.is_active:
            raise ValueError("User not found or inactive")
        
        # éªŒè¯å¯†ç 
        if not bcrypt.checkpw(
            credentials.password.encode(), 
            user.password_hash.encode()
        ):
            raise ValueError("Invalid password")
        
        # ç”ŸæˆJWTä»¤ç‰Œ
        payload = {
            "user_id": user.id,
            "email": user.email,
            "exp": datetime.utcnow() + timedelta(hours=24)
        }
        token = jwt.encode(payload, self.secret_key, algorithm="HS256")
        
        # ä¿å­˜ä¼šè¯
        session = Session(
            user_id=user.id,
            token=token,
            expires_at=datetime.utcnow() + timedelta(hours=24)
        )
        await self.session_repo.create(session)
        
        return token
    
    async def logout(self, token: str):
        """ç”¨æˆ·ç™»å‡º"""
        session = await self.session_repo.get_by_token(token)
        if session:
            await self.session_repo.delete(session.id)
```

### **2. äº¤æ˜“æœåŠ¡ (Trading Service)**

#### **èŒè´£èŒƒå›´**
- è®¢å•ç®¡ç† (åˆ›å»ºã€ä¿®æ”¹ã€å–æ¶ˆ)
- æŒä»“ç®¡ç†
- äº¤æ˜“è®°å½•
- èµ„é‡‘ç®¡ç†

#### **æŠ€æœ¯æ¶æ„**
```python
äº¤æ˜“æœåŠ¡/
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ order_controller.py     # è®¢å•æ§åˆ¶å™¨
â”‚   â”œâ”€â”€ position_controller.py  # æŒä»“æ§åˆ¶å™¨
â”‚   â””â”€â”€ trade_controller.py     # äº¤æ˜“æ§åˆ¶å™¨
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ order_service.py        # è®¢å•æœåŠ¡
â”‚   â”œâ”€â”€ position_service.py     # æŒä»“æœåŠ¡
â”‚   â””â”€â”€ trade_service.py        # äº¤æ˜“æœåŠ¡
â”œâ”€â”€ repositories/
â”‚   â”œâ”€â”€ order_repository.py     # è®¢å•ä»“å‚¨
â”‚   â”œâ”€â”€ position_repository.py  # æŒä»“ä»“å‚¨
â”‚   â””â”€â”€ trade_repository.py     # äº¤æ˜“ä»“å‚¨
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ order.py               # è®¢å•æ¨¡å‹
â”‚   â”œâ”€â”€ position.py            # æŒä»“æ¨¡å‹
â”‚   â””â”€â”€ trade.py               # äº¤æ˜“æ¨¡å‹
â””â”€â”€ events/
    â”œâ”€â”€ order_events.py        # è®¢å•äº‹ä»¶
    â””â”€â”€ trade_events.py        # äº¤æ˜“äº‹ä»¶
```

#### **æ ¸å¿ƒæœåŠ¡å®ç°**
```python
# services/order_service.py
from typing import List, Optional
from models.order import Order, OrderStatus, OrderType
from events.order_events import OrderCreatedEvent, OrderFilledEvent

class OrderService:
    def __init__(self, order_repo: OrderRepository, event_bus: EventBus):
        self.order_repo = order_repo
        self.event_bus = event_bus
    
    async def create_order(self, order_data: CreateOrderRequest) -> Order:
        """åˆ›å»ºè®¢å•"""
        # åˆ›å»ºè®¢å•å¯¹è±¡
        order = Order(
            user_id=order_data.user_id,
            symbol=order_data.symbol,
            side=order_data.side,
            order_type=order_data.order_type,
            quantity=order_data.quantity,
            price=order_data.price,
            status=OrderStatus.PENDING
        )
        
        # ä¿å­˜è®¢å•
        saved_order = await self.order_repo.create(order)
        
        # å‘å¸ƒè®¢å•åˆ›å»ºäº‹ä»¶
        event = OrderCreatedEvent(
            order_id=saved_order.id,
            user_id=saved_order.user_id,
            symbol=saved_order.symbol,
            quantity=saved_order.quantity,
            price=saved_order.price
        )
        await self.event_bus.publish(event)
        
        return saved_order
    
    async def cancel_order(self, order_id: str, user_id: str) -> bool:
        """å–æ¶ˆè®¢å•"""
        order = await self.order_repo.get_by_id(order_id)
        if not order or order.user_id != user_id:
            raise ValueError("Order not found or access denied")
        
        if order.status not in [OrderStatus.PENDING, OrderStatus.PARTIAL_FILLED]:
            raise ValueError("Cannot cancel order in current status")
        
        # æ›´æ–°è®¢å•çŠ¶æ€
        order.status = OrderStatus.CANCELLED
        await self.order_repo.update(order)
        
        # å‘å¸ƒè®¢å•å–æ¶ˆäº‹ä»¶
        event = OrderCancelledEvent(order_id=order.id)
        await self.event_bus.publish(event)
        
        return True
    
    async def get_user_orders(
        self, 
        user_id: str, 
        status: Optional[OrderStatus] = None
    ) -> List[Order]:
        """è·å–ç”¨æˆ·è®¢å•"""
        return await self.order_repo.get_by_user_id(user_id, status)
```

### **3. ç­–ç•¥æœåŠ¡ (Strategy Service)**

#### **èŒè´£èŒƒå›´**
- ç­–ç•¥ç®¡ç† (åˆ›å»ºã€å¯åŠ¨ã€åœæ­¢)
- ç­–ç•¥å‚æ•°é…ç½®
- ç­–ç•¥è¿è¡ŒçŠ¶æ€ç›‘æ§
- ç­–ç•¥æ€§èƒ½ç»Ÿè®¡

#### **æŠ€æœ¯æ¶æ„**
```python
ç­–ç•¥æœåŠ¡/
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ strategy_controller.py   # ç­–ç•¥æ§åˆ¶å™¨
â”‚   â””â”€â”€ backtest_controller.py   # å›æµ‹æ§åˆ¶å™¨
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ strategy_service.py      # ç­–ç•¥æœåŠ¡
â”‚   â”œâ”€â”€ backtest_service.py      # å›æµ‹æœåŠ¡
â”‚   â””â”€â”€ engine_service.py        # å¼•æ“æœåŠ¡
â”œâ”€â”€ engine/
â”‚   â”œâ”€â”€ strategy_engine.py       # ç­–ç•¥å¼•æ“
â”‚   â”œâ”€â”€ base_strategy.py         # ç­–ç•¥åŸºç±»
â”‚   â””â”€â”€ indicators/              # æŠ€æœ¯æŒ‡æ ‡
â”œâ”€â”€ repositories/
â”‚   â””â”€â”€ strategy_repository.py   # ç­–ç•¥ä»“å‚¨
â””â”€â”€ models/
    â”œâ”€â”€ strategy.py              # ç­–ç•¥æ¨¡å‹
    â””â”€â”€ backtest.py              # å›æµ‹æ¨¡å‹
```

#### **ç­–ç•¥å¼•æ“å®ç°**
```python
# engine/strategy_engine.py
from typing import Dict, List
import asyncio
from abc import ABC, abstractmethod

class StrategyEngine:
    def __init__(self):
        self.strategies: Dict[str, BaseStrategy] = {}
        self.running = False
        self.market_data_subscriber = None
    
    async def add_strategy(self, strategy_id: str, strategy: 'BaseStrategy'):
        """æ·»åŠ ç­–ç•¥"""
        self.strategies[strategy_id] = strategy
        await strategy.initialize()
        
    async def start_strategy(self, strategy_id: str):
        """å¯åŠ¨ç­–ç•¥"""
        if strategy_id not in self.strategies:
            raise ValueError(f"Strategy {strategy_id} not found")
        
        strategy = self.strategies[strategy_id]
        await strategy.start()
        
    async def stop_strategy(self, strategy_id: str):
        """åœæ­¢ç­–ç•¥"""
        if strategy_id not in self.strategies:
            raise ValueError(f"Strategy {strategy_id} not found")
        
        strategy = self.strategies[strategy_id]
        await strategy.stop()
    
    async def on_market_data(self, market_data: MarketData):
        """å¤„ç†å¸‚åœºæ•°æ®"""
        for strategy in self.strategies.values():
            if strategy.is_running():
                await strategy.on_tick(market_data)

class BaseStrategy(ABC):
    def __init__(self, strategy_id: str, config: Dict):
        self.strategy_id = strategy_id
        self.config = config
        self.running = False
        self.positions = {}
        self.orders = {}
    
    @abstractmethod
    async def initialize(self):
        """ç­–ç•¥åˆå§‹åŒ–"""
        pass
    
    @abstractmethod
    async def on_tick(self, market_data: MarketData):
        """å¤„ç†å¸‚åœºæ•°æ®"""
        pass
    
    async def start(self):
        """å¯åŠ¨ç­–ç•¥"""
        self.running = True
        
    async def stop(self):
        """åœæ­¢ç­–ç•¥"""
        self.running = False
    
    def is_running(self) -> bool:
        """æ£€æŸ¥ç­–ç•¥æ˜¯å¦è¿è¡Œä¸­"""
        return self.running
    
    async def buy(self, symbol: str, quantity: float, price: float = None):
        """ä¹°å…¥"""
        order_data = {
            "symbol": symbol,
            "side": "buy",
            "quantity": quantity,
            "price": price,
            "order_type": "market" if price is None else "limit"
        }
        # å‘é€åˆ°äº¤æ˜“æœåŠ¡
        await self._send_order(order_data)
    
    async def sell(self, symbol: str, quantity: float, price: float = None):
        """å–å‡º"""
        order_data = {
            "symbol": symbol,
            "side": "sell", 
            "quantity": quantity,
            "price": price,
            "order_type": "market" if price is None else "limit"
        }
        # å‘é€åˆ°äº¤æ˜“æœåŠ¡
        await self._send_order(order_data)
    
    async def _send_order(self, order_data: Dict):
        """å‘é€è®¢å•åˆ°äº¤æ˜“æœåŠ¡"""
        # é€šè¿‡HTTP APIè°ƒç”¨äº¤æ˜“æœåŠ¡
        pass
```

### **4. é…ç½®ç®¡ç†æœåŠ¡ (Configuration Service)**

#### **èŒè´£èŒƒå›´**
- é›†ä¸­å¼é…ç½®ç®¡ç†
- å¤šç¯å¢ƒé…ç½®éš”ç¦»
- é…ç½®çƒ­æ›´æ–°
- é…ç½®ç‰ˆæœ¬æ§åˆ¶

#### **æŠ€æœ¯æ¶æ„**
```python
é…ç½®æœåŠ¡/
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ config_controller.py    # é…ç½®æ§åˆ¶å™¨
â”‚   â””â”€â”€ env_controller.py       # ç¯å¢ƒæ§åˆ¶å™¨
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ config_service.py       # é…ç½®æœåŠ¡
â”‚   â”œâ”€â”€ validation_service.py   # éªŒè¯æœåŠ¡
â”‚   â””â”€â”€ notification_service.py # é€šçŸ¥æœåŠ¡
â”œâ”€â”€ repositories/
â”‚   â”œâ”€â”€ config_repository.py    # é…ç½®ä»“å‚¨
â”‚   â””â”€â”€ version_repository.py   # ç‰ˆæœ¬ä»“å‚¨
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ config.py              # é…ç½®æ¨¡å‹
â”‚   â””â”€â”€ version.py             # ç‰ˆæœ¬æ¨¡å‹
â””â”€â”€ watchers/
    â””â”€â”€ config_watcher.py      # é…ç½®ç›‘å¬å™¨
```

#### **é…ç½®æœåŠ¡å®ç°**
```python
# services/config_service.py
from typing import Dict, Any, Optional
import json
import asyncio
from models.config import Config
from events.config_events import ConfigChangedEvent

class ConfigService:
    def __init__(self, config_repo: ConfigRepository, event_bus: EventBus):
        self.config_repo = config_repo
        self.event_bus = event_bus
        self.cache = {}
    
    async def get_config(
        self, 
        service_name: str, 
        key: str, 
        environment: str = "production"
    ) -> Any:
        """è·å–é…ç½®å€¼"""
        cache_key = f"{service_name}:{key}:{environment}"
        
        # æ£€æŸ¥ç¼“å­˜
        if cache_key in self.cache:
            return self.cache[cache_key]
        
        # ä»æ•°æ®åº“è·å–
        config = await self.config_repo.get_config(service_name, key, environment)
        if config:
            self.cache[cache_key] = config.value
            return config.value
        
        return None
    
    async def set_config(
        self,
        service_name: str,
        key: str,
        value: Any,
        environment: str = "production",
        changed_by: str = "system"
    ) -> Config:
        """è®¾ç½®é…ç½®å€¼"""
        # è·å–æ—§å€¼
        old_value = await self.get_config(service_name, key, environment)
        
        # åˆ›å»ºæˆ–æ›´æ–°é…ç½®
        config = Config(
            service_name=service_name,
            key=key,
            value=value,
            environment=environment,
            changed_by=changed_by
        )
        
        saved_config = await self.config_repo.save(config)
        
        # æ›´æ–°ç¼“å­˜
        cache_key = f"{service_name}:{key}:{environment}"
        self.cache[cache_key] = value
        
        # å‘å¸ƒé…ç½®å˜æ›´äº‹ä»¶
        event = ConfigChangedEvent(
            service_name=service_name,
            key=key,
            old_value=old_value,
            new_value=value,
            environment=environment,
            changed_by=changed_by
        )
        await self.event_bus.publish(event)
        
        return saved_config
    
    async def get_service_configs(
        self, 
        service_name: str, 
        environment: str = "production"
    ) -> Dict[str, Any]:
        """è·å–æœåŠ¡çš„æ‰€æœ‰é…ç½®"""
        configs = await self.config_repo.get_service_configs(service_name, environment)
        return {config.key: config.value for config in configs}
    
    async def subscribe_to_changes(
        self, 
        service_name: str, 
        callback: callable,
        environment: str = "production"
    ):
        """è®¢é˜…é…ç½®å˜æ›´"""
        # æ³¨å†Œå›è°ƒå‡½æ•°
        await self.event_bus.subscribe(
            f"config_changed:{service_name}:{environment}",
            callback
        )
```

---

## ğŸŒ æœåŠ¡é—´é€šä¿¡è®¾è®¡

### **1. åŒæ­¥é€šä¿¡ (HTTP API)**

#### **APIç½‘å…³è·¯ç”±é…ç½®**
```yaml
# api-gateway.yaml
routes:
  # ç”¨æˆ·æœåŠ¡è·¯ç”±
  - path: /api/users/*
    service: user-service
    port: 8001
    health_check: /health
    
  # äº¤æ˜“æœåŠ¡è·¯ç”±  
  - path: /api/trading/*
    service: trading-service
    port: 8002
    health_check: /health
    
  # ç­–ç•¥æœåŠ¡è·¯ç”±
  - path: /api/strategies/*
    service: strategy-service
    port: 8003
    health_check: /health
    
  # é…ç½®æœåŠ¡è·¯ç”±
  - path: /api/config/*
    service: config-service
    port: 8004
    health_check: /health

middleware:
  - name: authentication
    config:
      jwt_secret: ${JWT_SECRET}
      exclude_paths: ["/api/users/register", "/api/users/login"]
      
  - name: rate_limiting
    config:
      requests_per_minute: 1000
      
  - name: cors
    config:
      allowed_origins: ["http://localhost:3000"]
      allowed_methods: ["GET", "POST", "PUT", "DELETE"]
```

#### **æœåŠ¡å‘ç°é…ç½®**
```python
# service_discovery.py
import consul
from typing import Dict, List

class ServiceDiscovery:
    def __init__(self, consul_host: str = "localhost", consul_port: int = 8500):
        self.consul = consul.Consul(host=consul_host, port=consul_port)
    
    async def register_service(
        self, 
        service_name: str, 
        service_id: str,
        host: str, 
        port: int,
        health_check_url: str
    ):
        """æ³¨å†ŒæœåŠ¡"""
        self.consul.agent.service.register(
            name=service_name,
            service_id=service_id,
            address=host,
            port=port,
            check=consul.Check.http(health_check_url, interval="10s")
        )
    
    async def discover_service(self, service_name: str) -> List[Dict]:
        """å‘ç°æœåŠ¡"""
        _, services = self.consul.health.service(service_name, passing=True)
        return [
            {
                "host": service["Service"]["Address"],
                "port": service["Service"]["Port"]
            }
            for service in services
        ]
    
    async def deregister_service(self, service_id: str):
        """æ³¨é”€æœåŠ¡"""
        self.consul.agent.service.deregister(service_id)
```

### **2. å¼‚æ­¥é€šä¿¡ (æ¶ˆæ¯é˜Ÿåˆ—)**

#### **äº‹ä»¶æ€»çº¿è®¾è®¡**
```python
# event_bus.py
import asyncio
import json
from typing import Dict, List, Callable
from abc import ABC, abstractmethod
import aio_pika

class Event(ABC):
    @abstractmethod
    def to_dict(self) -> Dict:
        pass
    
    @classmethod
    @abstractmethod 
    def from_dict(cls, data: Dict):
        pass

class OrderCreatedEvent(Event):
    def __init__(self, order_id: str, user_id: str, symbol: str, quantity: float):
        self.order_id = order_id
        self.user_id = user_id
        self.symbol = symbol
        self.quantity = quantity
        self.event_type = "order_created"
    
    def to_dict(self) -> Dict:
        return {
            "event_type": self.event_type,
            "order_id": self.order_id,
            "user_id": self.user_id,
            "symbol": self.symbol,
            "quantity": self.quantity
        }
    
    @classmethod
    def from_dict(cls, data: Dict):
        return cls(
            order_id=data["order_id"],
            user_id=data["user_id"],
            symbol=data["symbol"],
            quantity=data["quantity"]
        )

class EventBus:
    def __init__(self, rabbitmq_url: str):
        self.rabbitmq_url = rabbitmq_url
        self.connection = None
        self.channel = None
        self.subscribers: Dict[str, List[Callable]] = {}
    
    async def connect(self):
        """è¿æ¥æ¶ˆæ¯é˜Ÿåˆ—"""
        self.connection = await aio_pika.connect_robust(self.rabbitmq_url)
        self.channel = await self.connection.channel()
    
    async def publish(self, event: Event, routing_key: str = None):
        """å‘å¸ƒäº‹ä»¶"""
        if not self.channel:
            await self.connect()
        
        routing_key = routing_key or event.event_type
        exchange = await self.channel.declare_exchange(
            "events", aio_pika.ExchangeType.TOPIC
        )
        
        message = aio_pika.Message(
            json.dumps(event.to_dict()).encode(),
            content_type="application/json"
        )
        
        await exchange.publish(message, routing_key=routing_key)
    
    async def subscribe(self, event_pattern: str, callback: Callable):
        """è®¢é˜…äº‹ä»¶"""
        if not self.channel:
            await self.connect()
        
        exchange = await self.channel.declare_exchange(
            "events", aio_pika.ExchangeType.TOPIC
        )
        
        queue = await self.channel.declare_queue("", exclusive=True)
        await queue.bind(exchange, routing_key=event_pattern)
        
        async def message_handler(message: aio_pika.IncomingMessage):
            async with message.process():
                try:
                    data = json.loads(message.body.decode())
                    await callback(data)
                except Exception as e:
                    logger.error(f"Error processing message: {e}")
        
        await queue.consume(message_handler)
```

---

## ğŸ“Š æ•°æ®ç®¡ç†è®¾è®¡

### **1. æ•°æ®åº“æ¶æ„**

#### **æ•°æ®åº“åˆ†å¸ƒç­–ç•¥**
```yaml
# æ•°æ®åº“åˆ†å¸ƒè®¾è®¡
æ•°æ®åº“åˆ†å¸ƒ:
  ç”¨æˆ·æœåŠ¡:
    æ•°æ®åº“: user_db
    è¡¨: [users, sessions, profiles]
    åˆ†ç‰‡ç­–ç•¥: æŒ‰user_idåˆ†ç‰‡
    
  äº¤æ˜“æœåŠ¡:
    æ•°æ®åº“: trading_db  
    è¡¨: [orders, trades, positions, accounts]
    åˆ†ç‰‡ç­–ç•¥: æŒ‰user_id + æ—¶é—´åˆ†ç‰‡
    
  ç­–ç•¥æœåŠ¡:
    æ•°æ®åº“: strategy_db
    è¡¨: [strategies, backtests, parameters]
    åˆ†ç‰‡ç­–ç•¥: æŒ‰user_idåˆ†ç‰‡
    
  é…ç½®æœåŠ¡:
    æ•°æ®åº“: config_db
    è¡¨: [configs, versions, environments]
    åˆ†ç‰‡ç­–ç•¥: æŒ‰service_nameåˆ†ç‰‡
    
  è¡Œæƒ…æ•°æ®:
    æ•°æ®åº“: market_db (InfluxDB)
    è¡¨: [ticks, bars, indicators]
    åˆ†ç‰‡ç­–ç•¥: æŒ‰symbol + æ—¶é—´åˆ†ç‰‡
```

#### **æ•°æ®æ¨¡å‹è®¾è®¡**
```python
# models/user.py
from sqlalchemy import Column, String, Integer, DateTime, Boolean
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    
    id = Column(String(36), primary_key=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    password_hash = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, nullable=False)
    updated_at = Column(DateTime)

# models/order.py
class Order(Base):
    __tablename__ = "orders"
    
    id = Column(String(36), primary_key=True)
    user_id = Column(String(36), nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    side = Column(String(4), nullable=False)  # BUY/SELL
    order_type = Column(String(10), nullable=False)  # MARKET/LIMIT
    quantity = Column(Integer, nullable=False)
    price = Column(String(20))  # ä½¿ç”¨å­—ç¬¦ä¸²å­˜å‚¨ç²¾ç¡®ä»·æ ¼
    status = Column(String(20), nullable=False, index=True)
    created_at = Column(DateTime, nullable=False, index=True)
    updated_at = Column(DateTime)

# models/strategy.py  
class Strategy(Base):
    __tablename__ = "strategies"
    
    id = Column(String(36), primary_key=True)
    user_id = Column(String(36), nullable=False, index=True)
    name = Column(String(100), nullable=False)
    class_name = Column(String(100), nullable=False)
    symbol = Column(String(20), nullable=False)
    parameters = Column(String(2000))  # JSONæ ¼å¼å‚æ•°
    status = Column(String(20), nullable=False, index=True)
    created_at = Column(DateTime, nullable=False)
    updated_at = Column(DateTime)
```

### **2. ç¼“å­˜è®¾è®¡**

#### **å¤šçº§ç¼“å­˜æ¶æ„**
```python
# cache/multi_level_cache.py
from typing import Any, Optional
import json
import asyncio
import redis.asyncio as redis

class MultiLevelCache:
    def __init__(self, redis_url: str):
        self.l1_cache = {}  # æœ¬åœ°å†…å­˜ç¼“å­˜
        self.l2_cache = redis.from_url(redis_url)  # Redisç¼“å­˜
        self.lock = asyncio.Lock()
    
    async def get(self, key: str) -> Optional[Any]:
        """è·å–ç¼“å­˜ - L1 -> L2 -> None"""
        # L1ç¼“å­˜æŸ¥æ‰¾
        if key in self.l1_cache:
            return self.l1_cache[key]
        
        # L2ç¼“å­˜æŸ¥æ‰¾
        try:
            value = await self.l2_cache.get(key)
            if value:
                decoded_value = json.loads(value)
                # å›å¡«L1ç¼“å­˜
                self.l1_cache[key] = decoded_value
                return decoded_value
        except Exception as e:
            logger.error(f"Redis cache error: {e}")
        
        return None
    
    async def set(self, key: str, value: Any, ttl: int = 3600):
        """è®¾ç½®ç¼“å­˜ - L1 + L2"""
        async with self.lock:
            # è®¾ç½®L1ç¼“å­˜
            self.l1_cache[key] = value
            
            # è®¾ç½®L2ç¼“å­˜
            try:
                await self.l2_cache.setex(key, ttl, json.dumps(value, default=str))
            except Exception as e:
                logger.error(f"Redis cache set error: {e}")
    
    async def delete(self, key: str):
        """åˆ é™¤ç¼“å­˜"""
        # åˆ é™¤L1ç¼“å­˜
        self.l1_cache.pop(key, None)
        
        # åˆ é™¤L2ç¼“å­˜
        try:
            await self.l2_cache.delete(key)
        except Exception as e:
            logger.error(f"Redis cache delete error: {e}")
    
    async def invalidate_pattern(self, pattern: str):
        """æŒ‰æ¨¡å¼å¤±æ•ˆç¼“å­˜"""
        # æ¸…ç©ºL1ç¼“å­˜ä¸­åŒ¹é…çš„é”®
        keys_to_remove = [k for k in self.l1_cache.keys() if pattern in k]
        for key in keys_to_remove:
            del self.l1_cache[key]
        
        # æ¸…ç©ºL2ç¼“å­˜ä¸­åŒ¹é…çš„é”®
        try:
            keys = await self.l2_cache.keys(pattern)
            if keys:
                await self.l2_cache.delete(*keys)
        except Exception as e:
            logger.error(f"Redis pattern delete error: {e}")
```

---

## ğŸ”’ å®‰å…¨è®¾è®¡

### **1. è®¤è¯æˆæƒæ¶æ„**

#### **JWTè®¤è¯å®ç°**
```python
# security/jwt_auth.py
import jwt
from datetime import datetime, timedelta
from typing import Optional, Dict
from fastapi import HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

security = HTTPBearer()

class JWTManager:
    def __init__(self, secret_key: str, algorithm: str = "HS256"):
        self.secret_key = secret_key
        self.algorithm = algorithm
        self.access_token_expire = timedelta(hours=24)
        self.refresh_token_expire = timedelta(days=30)
    
    def create_access_token(self, data: Dict) -> str:
        """åˆ›å»ºè®¿é—®ä»¤ç‰Œ"""
        to_encode = data.copy()
        expire = datetime.utcnow() + self.access_token_expire
        to_encode.update({"exp": expire, "type": "access"})
        
        return jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
    
    def create_refresh_token(self, data: Dict) -> str:
        """åˆ›å»ºåˆ·æ–°ä»¤ç‰Œ"""
        to_encode = data.copy()
        expire = datetime.utcnow() + self.refresh_token_expire
        to_encode.update({"exp": expire, "type": "refresh"})
        
        return jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
    
    def verify_token(self, token: str) -> Optional[Dict]:
        """éªŒè¯ä»¤ç‰Œ"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(status_code=401, detail="Token expired")
        except jwt.JWTError:
            raise HTTPException(status_code=401, detail="Invalid token")

# ä¾èµ–æ³¨å…¥å‡½æ•°
async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    jwt_manager: JWTManager = Depends()
) -> Dict:
    """è·å–å½“å‰ç”¨æˆ·"""
    token = credentials.credentials
    payload = jwt_manager.verify_token(token)
    
    if payload.get("type") != "access":
        raise HTTPException(status_code=401, detail="Invalid token type")
    
    return payload
```

#### **æƒé™æ§åˆ¶å®ç°**
```python
# security/rbac.py
from enum import Enum
from typing import List, Set
from functools import wraps
from fastapi import HTTPException

class Permission(Enum):
    # ç”¨æˆ·æƒé™
    USER_READ = "user:read"
    USER_WRITE = "user:write"
    USER_DELETE = "user:delete"
    
    # äº¤æ˜“æƒé™
    TRADING_READ = "trading:read"
    TRADING_WRITE = "trading:write"
    TRADING_DELETE = "trading:delete"
    
    # ç­–ç•¥æƒé™
    STRATEGY_READ = "strategy:read"
    STRATEGY_WRITE = "strategy:write"
    STRATEGY_DELETE = "strategy:delete"
    
    # ç®¡ç†å‘˜æƒé™
    ADMIN_ALL = "admin:all"

class Role(Enum):
    GUEST = "guest"
    USER = "user"
    TRADER = "trader"
    ADMIN = "admin"

# è§’è‰²æƒé™æ˜ å°„
ROLE_PERMISSIONS = {
    Role.GUEST: [Permission.USER_READ],
    Role.USER: [
        Permission.USER_READ, Permission.USER_WRITE,
        Permission.TRADING_READ, Permission.STRATEGY_READ
    ],
    Role.TRADER: [
        Permission.USER_READ, Permission.USER_WRITE,
        Permission.TRADING_READ, Permission.TRADING_WRITE,
        Permission.STRATEGY_READ, Permission.STRATEGY_WRITE
    ],
    Role.ADMIN: [Permission.ADMIN_ALL]
}

def require_permission(permission: Permission):
    """æƒé™è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # ä»è¯·æ±‚ä¸­è·å–ç”¨æˆ·ä¿¡æ¯
            user = kwargs.get('current_user')
            if not user:
                raise HTTPException(status_code=401, detail="Authentication required")
            
            # æ£€æŸ¥æƒé™
            user_role = Role(user.get('role', 'guest'))
            user_permissions = ROLE_PERMISSIONS.get(user_role, [])
            
            if Permission.ADMIN_ALL in user_permissions or permission in user_permissions:
                return await func(*args, **kwargs)
            else:
                raise HTTPException(status_code=403, detail="Insufficient permissions")
        
        return wrapper
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
@require_permission(Permission.TRADING_WRITE)
async def create_order(order_data: CreateOrderRequest, current_user: Dict = Depends(get_current_user)):
    """åˆ›å»ºè®¢å• - éœ€è¦äº¤æ˜“å†™æƒé™"""
    pass
```

### **2. APIå®‰å…¨å¢å¼º**

#### **é€Ÿç‡é™åˆ¶å®ç°**
```python
# security/rate_limiter.py
import time
from typing import Dict, Tuple
from fastapi import HTTPException, Request
import redis.asyncio as redis

class RateLimiter:
    def __init__(self, redis_url: str):
        self.redis = redis.from_url(redis_url)
        self.rules = {
            "default": {"requests": 100, "window": 60},  # 100æ¬¡/åˆ†é’Ÿ
            "auth": {"requests": 10, "window": 60},      # 10æ¬¡/åˆ†é’Ÿ  
            "trading": {"requests": 300, "window": 60},  # 300æ¬¡/åˆ†é’Ÿ
        }
    
    async def is_allowed(self, key: str, rule_name: str = "default") -> Tuple[bool, Dict]:
        """æ£€æŸ¥æ˜¯å¦å…è®¸è¯·æ±‚"""
        rule = self.rules.get(rule_name, self.rules["default"])
        window = rule["window"]
        limit = rule["requests"]
        
        current_time = int(time.time())
        window_start = current_time - window
        
        # ä½¿ç”¨Redisæ»‘åŠ¨çª—å£ç®—æ³•
        pipe = self.redis.pipeline()
        
        # ç§»é™¤è¿‡æœŸçš„è®°å½•
        pipe.zremrangebyscore(key, 0, window_start)
        
        # æ·»åŠ å½“å‰è¯·æ±‚
        pipe.zadd(key, {str(current_time): current_time})
        
        # è·å–å½“å‰çª—å£å†…çš„è¯·æ±‚æ•°
        pipe.zcard(key)
        
        # è®¾ç½®è¿‡æœŸæ—¶é—´
        pipe.expire(key, window)
        
        results = await pipe.execute()
        request_count = results[2]
        
        allowed = request_count <= limit
        remaining = max(0, limit - request_count)
        
        return allowed, {
            "limit": limit,
            "remaining": remaining,
            "reset_time": current_time + window
        }

async def rate_limit_middleware(request: Request, call_next):
    """é€Ÿç‡é™åˆ¶ä¸­é—´ä»¶"""
    # è·å–å®¢æˆ·ç«¯æ ‡è¯†
    client_ip = request.client.host
    endpoint = request.url.path
    
    # ç¡®å®šé™æµè§„åˆ™
    rule_name = "default"
    if "/auth/" in endpoint:
        rule_name = "auth"
    elif "/trading/" in endpoint:
        rule_name = "trading"
    
    # æ£€æŸ¥é€Ÿç‡é™åˆ¶
    limiter = RateLimiter("redis://localhost:6379")
    key = f"rate_limit:{client_ip}:{rule_name}"
    
    allowed, info = await limiter.is_allowed(key, rule_name)
    
    if not allowed:
        raise HTTPException(
            status_code=429, 
            detail="Rate limit exceeded",
            headers={
                "X-RateLimit-Limit": str(info["limit"]),
                "X-RateLimit-Remaining": str(info["remaining"]),
                "X-RateLimit-Reset": str(info["reset_time"])
            }
        )
    
    response = await call_next(request)
    
    # æ·»åŠ é€Ÿç‡é™åˆ¶å¤´éƒ¨
    response.headers["X-RateLimit-Limit"] = str(info["limit"])
    response.headers["X-RateLimit-Remaining"] = str(info["remaining"])
    response.headers["X-RateLimit-Reset"] = str(info["reset_time"])
    
    return response
```

---

## ğŸ“Š ç›‘æ§ä¸å¯è§‚æµ‹æ€§

### **1. æŒ‡æ ‡æ”¶é›†**

#### **PrometheusæŒ‡æ ‡å®šä¹‰**
```python
# monitoring/metrics.py
from prometheus_client import Counter, Histogram, Gauge, Info
import time
from functools import wraps

# ä¸šåŠ¡æŒ‡æ ‡
orders_total = Counter('orders_total', 'Total orders', ['service', 'status', 'symbol'])
order_processing_time = Histogram('order_processing_seconds', 'Order processing time', ['service'])
active_strategies = Gauge('active_strategies', 'Number of active strategies', ['service'])
user_sessions = Gauge('user_sessions', 'Number of active user sessions')

# æŠ€æœ¯æŒ‡æ ‡
http_requests_total = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint', 'status'])
http_request_duration = Histogram('http_request_duration_seconds', 'HTTP request duration')
database_connections = Gauge('database_connections', 'Database connections', ['service', 'status'])
cache_operations = Counter('cache_operations_total', 'Cache operations', ['service', 'operation', 'result'])

# ç³»ç»ŸæŒ‡æ ‡
service_info = Info('service_info', 'Service information')
service_up = Gauge('service_up', 'Service up status', ['service'])

class MetricsCollector:
    @staticmethod
    def record_order(service: str, status: str, symbol: str, processing_time: float):
        """è®°å½•è®¢å•æŒ‡æ ‡"""
        orders_total.labels(service=service, status=status, symbol=symbol).inc()
        order_processing_time.labels(service=service).observe(processing_time)
    
    @staticmethod
    def record_http_request(method: str, endpoint: str, status: int, duration: float):
        """è®°å½•HTTPè¯·æ±‚æŒ‡æ ‡"""
        http_requests_total.labels(method=method, endpoint=endpoint, status=status).inc()
        http_request_duration.observe(duration)
    
    @staticmethod
    def set_active_strategies(service: str, count: int):
        """è®¾ç½®æ´»è·ƒç­–ç•¥æ•°é‡"""
        active_strategies.labels(service=service).set(count)
    
    @staticmethod
    def record_cache_operation(service: str, operation: str, result: str):
        """è®°å½•ç¼“å­˜æ“ä½œ"""
        cache_operations.labels(service=service, operation=operation, result=result).inc()

def monitor_performance(metric_name: str = None):
    """æ€§èƒ½ç›‘æ§è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = await func(*args, **kwargs)
                duration = time.time() - start_time
                
                # è®°å½•æˆåŠŸæŒ‡æ ‡
                if metric_name:
                    globals()[metric_name].observe(duration)
                
                return result
            except Exception as e:
                duration = time.time() - start_time
                # è®°å½•å¤±è´¥æŒ‡æ ‡
                logger.error(f"{func.__name__} failed after {duration:.4f}s: {e}")
                raise
        return wrapper
    return decorator
```

### **2. æ—¥å¿—èšåˆ**

#### **ç»“æ„åŒ–æ—¥å¿—å®ç°**
```python
# monitoring/structured_logging.py
import json
import logging
from datetime import datetime
from typing import Dict, Any
import traceback

class StructuredLogger:
    def __init__(self, service_name: str, version: str):
        self.service_name = service_name
        self.version = version
        self.logger = logging.getLogger(service_name)
        self.logger.setLevel(logging.INFO)
        
        # é…ç½®JSONæ ¼å¼è¾“å‡º
        handler = logging.StreamHandler()
        handler.setFormatter(JSONFormatter())
        self.logger.addHandler(handler)
    
    def info(self, message: str, extra: Dict[str, Any] = None, **kwargs):
        """è®°å½•ä¿¡æ¯æ—¥å¿—"""
        self._log("INFO", message, extra, **kwargs)
    
    def error(self, message: str, exception: Exception = None, extra: Dict[str, Any] = None, **kwargs):
        """è®°å½•é”™è¯¯æ—¥å¿—"""
        log_data = extra or {}
        if exception:
            log_data.update({
                "exception_type": type(exception).__name__,
                "exception_message": str(exception),
                "traceback": traceback.format_exc()
            })
        self._log("ERROR", message, log_data, **kwargs)
    
    def warning(self, message: str, extra: Dict[str, Any] = None, **kwargs):
        """è®°å½•è­¦å‘Šæ—¥å¿—"""
        self._log("WARNING", message, extra, **kwargs)
    
    def _log(self, level: str, message: str, extra: Dict[str, Any] = None, **kwargs):
        """å†…éƒ¨æ—¥å¿—æ–¹æ³•"""
        log_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": level,
            "service": self.service_name,
            "version": self.version,
            "message": message,
            **kwargs
        }
        
        if extra:
            log_data.update(extra)
        
        getattr(self.logger, level.lower())(json.dumps(log_data))

class JSONFormatter(logging.Formatter):
    def format(self, record):
        # å¦‚æœå·²ç»æ˜¯JSONæ ¼å¼ï¼Œç›´æ¥è¿”å›
        if hasattr(record, 'getMessage'):
            try:
                json.loads(record.getMessage())
                return record.getMessage()
            except:
                pass
        
        # å¦åˆ™æ ¼å¼åŒ–ä¸ºJSON
        log_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": record.levelname,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno
        }
        
        return json.dumps(log_data)

# ä½¿ç”¨ç¤ºä¾‹
logger = StructuredLogger("trading-service", "1.0.0")

async def create_order(order_data: Dict):
    logger.info(
        "Order creation started",
        extra={
            "user_id": order_data["user_id"],
            "symbol": order_data["symbol"],
            "quantity": order_data["quantity"]
        },
        correlation_id="12345",
        request_id="req_67890"
    )
    
    try:
        # è®¢å•å¤„ç†é€»è¾‘
        result = await process_order(order_data)
        
        logger.info(
            "Order created successfully",
            extra={
                "order_id": result["order_id"],
                "status": result["status"]
            },
            correlation_id="12345",
            request_id="req_67890"
        )
        
        return result
    except Exception as e:
        logger.error(
            "Order creation failed",
            exception=e,
            extra={
                "user_id": order_data["user_id"],
                "symbol": order_data["symbol"]
            },
            correlation_id="12345",
            request_id="req_67890"
        )
        raise
```

### **3. é“¾è·¯è¿½è¸ª**

#### **åˆ†å¸ƒå¼è¿½è¸ªå®ç°**
```python
# monitoring/tracing.py
import uuid
from typing import Optional, Dict
import asyncio
from contextvars import ContextVar
from functools import wraps

# ä¸Šä¸‹æ–‡å˜é‡
trace_context: ContextVar[Optional[Dict]] = ContextVar('trace_context', default=None)

class TraceContext:
    def __init__(self, trace_id: str = None, span_id: str = None, parent_span_id: str = None):
        self.trace_id = trace_id or str(uuid.uuid4())
        self.span_id = span_id or str(uuid.uuid4())
        self.parent_span_id = parent_span_id
        self.start_time = asyncio.get_event_loop().time()
        self.tags = {}
        self.logs = []
    
    def add_tag(self, key: str, value: str):
        """æ·»åŠ æ ‡ç­¾"""
        self.tags[key] = value
    
    def log(self, message: str, **kwargs):
        """æ·»åŠ æ—¥å¿—"""
        self.logs.append({
            "timestamp": asyncio.get_event_loop().time(),
            "message": message,
            **kwargs
        })
    
    def finish(self):
        """ç»“æŸspan"""
        self.end_time = asyncio.get_event_loop().time()
        self.duration = self.end_time - self.start_time
        
        # å‘é€åˆ°è¿½è¸ªç³»ç»Ÿ (Jaeger/Zipkin)
        self._send_to_tracer()
    
    def _send_to_tracer(self):
        """å‘é€è¿½è¸ªæ•°æ®"""
        span_data = {
            "trace_id": self.trace_id,
            "span_id": self.span_id,
            "parent_span_id": self.parent_span_id,
            "start_time": self.start_time,
            "duration": self.duration,
            "tags": self.tags,
            "logs": self.logs
        }
        # å®é™…å‘é€åˆ°Jaegerç­‰è¿½è¸ªç³»ç»Ÿ
        # jaeger_client.send_span(span_data)

def trace_async(operation_name: str = None):
    """å¼‚æ­¥è¿½è¸ªè£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # è·å–çˆ¶ä¸Šä¸‹æ–‡
            parent_context = trace_context.get()
            
            # åˆ›å»ºæ–°çš„span
            span = TraceContext(
                trace_id=parent_context.trace_id if parent_context else None,
                parent_span_id=parent_context.span_id if parent_context else None
            )
            
            span.add_tag("operation", operation_name or func.__name__)
            span.add_tag("function", f"{func.__module__}.{func.__name__}")
            
            # è®¾ç½®ä¸Šä¸‹æ–‡
            trace_context.set(span)
            
            try:
                result = await func(*args, **kwargs)
                span.add_tag("status", "success")
                return result
            except Exception as e:
                span.add_tag("status", "error")
                span.add_tag("error.message", str(e))
                span.log("Exception occurred", exception=str(e))
                raise
            finally:
                span.finish()
        
        return wrapper
    return decorator

# HTTPä¸­é—´ä»¶æ”¯æŒ
async def tracing_middleware(request, call_next):
    """è¿½è¸ªä¸­é—´ä»¶"""
    # ä»è¯·æ±‚å¤´è·å–è¿½è¸ªä¿¡æ¯
    trace_id = request.headers.get("X-Trace-Id")
    span_id = request.headers.get("X-Span-Id")
    
    # åˆ›å»ºspan
    span = TraceContext(trace_id=trace_id, parent_span_id=span_id)
    span.add_tag("http.method", request.method)
    span.add_tag("http.url", str(request.url))
    span.add_tag("http.user_agent", request.headers.get("user-agent", ""))
    
    # è®¾ç½®ä¸Šä¸‹æ–‡
    trace_context.set(span)
    
    try:
        response = await call_next(request)
        span.add_tag("http.status_code", response.status_code)
        
        # ä¼ é€’è¿½è¸ªä¿¡æ¯åˆ°å“åº”
        response.headers["X-Trace-Id"] = span.trace_id
        response.headers["X-Span-Id"] = span.span_id
        
        return response
    except Exception as e:
        span.add_tag("http.status_code", 500)
        span.add_tag("error", "true")
        span.log("Request failed", exception=str(e))
        raise
    finally:
        span.finish()

# ä½¿ç”¨ç¤ºä¾‹
@trace_async("create_order")
async def create_order(order_data: Dict):
    span = trace_context.get()
    span.add_tag("user_id", order_data["user_id"])
    span.add_tag("symbol", order_data["symbol"])
    span.log("Order creation started")
    
    # ä¸šåŠ¡é€»è¾‘
    result = await process_order(order_data)
    
    span.log("Order created", order_id=result["order_id"])
    return result
```

---

## ğŸš€ éƒ¨ç½²æ¶æ„

### **1. å®¹å™¨åŒ–éƒ¨ç½²**

#### **Docker Composeé…ç½®**
```yaml
# docker-compose.yml
version: '3.8'

services:
  # APIç½‘å…³
  api-gateway:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - user-service
      - trading-service
      - strategy-service
      - config-service
    networks:
      - redfire-network

  # ç”¨æˆ·æœåŠ¡
  user-service:
    build:
      context: ./services/user-service
      dockerfile: Dockerfile
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/user_db
      - REDIS_URL=redis://redis:6379/0
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - postgres
      - redis
    networks:
      - redfire-network
    deploy:
      replicas: 3

  # äº¤æ˜“æœåŠ¡
  trading-service:
    build:
      context: ./services/trading-service
      dockerfile: Dockerfile
    environment:
      - DATABASE_URL=postgresql://trading:password@postgres:5432/trading_db
      - REDIS_URL=redis://redis:6379/1
      - RABBITMQ_URL=amqp://rabbitmq:5672
    depends_on:
      - postgres
      - redis
      - rabbitmq
    networks:
      - redfire-network
    deploy:
      replicas: 3

  # ç­–ç•¥æœåŠ¡
  strategy-service:
    build:
      context: ./services/strategy-service
      dockerfile: Dockerfile
    environment:
      - DATABASE_URL=postgresql://strategy:password@postgres:5432/strategy_db
      - REDIS_URL=redis://redis:6379/2
      - VNPY_SERVICE_URL=http://vnpy-service:8005
    depends_on:
      - postgres
      - redis
      - vnpy-service
    networks:
      - redfire-network
    deploy:
      replicas: 2

  # é…ç½®æœåŠ¡
  config-service:
    build:
      context: ./services/config-service
      dockerfile: Dockerfile
    environment:
      - DATABASE_URL=postgresql://config:password@postgres:5432/config_db
      - REDIS_URL=redis://redis:6379/3
    depends_on:
      - postgres
      - redis
    networks:
      - redfire-network
    deploy:
      replicas: 2

  # VnPyå¼•æ“æœåŠ¡
  vnpy-service:
    build:
      context: ./services/vnpy-service
      dockerfile: Dockerfile
    environment:
      - CONFIG_SERVICE_URL=http://config-service:8004
    volumes:
      - ./vnpy_data:/app/data
    networks:
      - redfire-network
    deploy:
      replicas: 1

  # æ•°æ®åº“
  postgres:
    image: postgres:13
    environment:
      - POSTGRES_MULTIPLE_DATABASES=user_db,trading_db,strategy_db,config_db
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-db.sh:/docker-entrypoint-initdb.d/init-db.sh
    networks:
      - redfire-network

  # Redis
  redis:
    image: redis:6-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    networks:
      - redfire-network

  # æ¶ˆæ¯é˜Ÿåˆ—
  rabbitmq:
    image: rabbitmq:3-management
    environment:
      - RABBITMQ_DEFAULT_USER=redfire
      - RABBITMQ_DEFAULT_PASS=${RABBITMQ_PASSWORD}
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    ports:
      - "15672:15672"  # ç®¡ç†ç•Œé¢
    networks:
      - redfire-network

  # ç›‘æ§æœåŠ¡
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    networks:
      - redfire-network

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana:/etc/grafana/provisioning
    networks:
      - redfire-network

volumes:
  postgres_data:
  redis_data:
  rabbitmq_data:
  prometheus_data:
  grafana_data:

networks:
  redfire-network:
    driver: bridge
```

### **2. Kuberneteséƒ¨ç½²**

#### **K8séƒ¨ç½²é…ç½®**
```yaml
# k8s/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: redfire

---
# k8s/user-service.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
  namespace: redfire
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: redfire/user-service:latest
        ports:
        - containerPort: 8001
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secrets
              key: user-db-url
        - name: REDIS_URL
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: redis-url
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: auth-secrets
              key: jwt-secret
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8001
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8001
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: user-service
  namespace: redfire
spec:
  selector:
    app: user-service
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8001
  type: ClusterIP

---
# k8s/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: redfire-ingress
  namespace: redfire
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - api.redfire.com
    secretName: redfire-tls
  rules:
  - host: api.redfire.com
    http:
      paths:
      - path: /api/users
        pathType: Prefix
        backend:
          service:
            name: user-service
            port:
              number: 80
      - path: /api/trading
        pathType: Prefix
        backend:
          service:
            name: trading-service
            port:
              number: 80
      - path: /api/strategies
        pathType: Prefix
        backend:
          service:
            name: strategy-service
            port:
              number: 80
      - path: /api/config
        pathType: Prefix
        backend:
          service:
            name: config-service
            port:
              number: 80

---
# k8s/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: user-service-hpa
  namespace: redfire
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: user-service
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

---

## ğŸ“‹ è¿ç§»å®æ–½è®¡åˆ’

### **é˜¶æ®µ1: åŸºç¡€è®¾æ–½å‡†å¤‡ (Week 1-2)**
1. **å®¹å™¨åŒ–ç°æœ‰æœåŠ¡**
   - ä¸ºæ¯ä¸ªæœåŠ¡åˆ›å»ºDockerfile
   - é…ç½®Docker Composeç¯å¢ƒ
   - å»ºç«‹CI/CDæµæ°´çº¿

2. **éƒ¨ç½²åŸºç¡€ç»„ä»¶**
   - éƒ¨ç½²PostgreSQLé›†ç¾¤
   - éƒ¨ç½²Redisé›†ç¾¤
   - éƒ¨ç½²RabbitMQ
   - é…ç½®ç›‘æ§ç»„ä»¶

### **é˜¶æ®µ2: é…ç½®æœåŠ¡è¿ç§» (Week 3-4)**
1. **å®ç°é…ç½®å¾®æœåŠ¡**
   - å¼€å‘é…ç½®ç®¡ç†API
   - å®ç°é…ç½®æ¨é€æœºåˆ¶
   - å»ºç«‹é…ç½®ç‰ˆæœ¬æ§åˆ¶

2. **è¿ç§»ç°æœ‰é…ç½®**
   - åˆ†æç°æœ‰é…ç½®æ–‡ä»¶
   - æ‰¹é‡å¯¼å…¥åˆ°é…ç½®æœåŠ¡
   - éªŒè¯é…ç½®ä¸€è‡´æ€§

### **é˜¶æ®µ3: æ ¸å¿ƒæœåŠ¡æ‹†åˆ† (Week 5-8)**
1. **ç”¨æˆ·æœåŠ¡ç‹¬ç«‹**
   - æå–ç”¨æˆ·ç›¸å…³åŠŸèƒ½
   - å®ç°ç‹¬ç«‹çš„ç”¨æˆ·æ•°æ®åº“
   - å»ºç«‹JWTè®¤è¯æœºåˆ¶

2. **äº¤æ˜“æœåŠ¡ç‹¬ç«‹**
   - æå–äº¤æ˜“ç›¸å…³åŠŸèƒ½
   - å®ç°è®¢å•å’ŒæŒä»“ç®¡ç†
   - é›†æˆé£é™©æ§åˆ¶

3. **ç­–ç•¥æœåŠ¡ç‹¬ç«‹**
   - æå–ç­–ç•¥ç›¸å…³åŠŸèƒ½
   - å®ç°ç­–ç•¥å¼•æ“
   - é›†æˆVnPyæ¥å£

### **é˜¶æ®µ4: æœåŠ¡é›†æˆä¸æµ‹è¯• (Week 9-10)**
1. **æœåŠ¡é—´é€šä¿¡**
   - é…ç½®APIç½‘å…³
   - å®ç°æœåŠ¡å‘ç°
   - å»ºç«‹äº‹ä»¶æ€»çº¿

2. **ç«¯åˆ°ç«¯æµ‹è¯•**
   - åŠŸèƒ½å®Œæ•´æ€§æµ‹è¯•
   - æ€§èƒ½å‹åŠ›æµ‹è¯•
   - å®‰å…¨æ¸—é€æµ‹è¯•

### **é˜¶æ®µ5: ç”Ÿäº§éƒ¨ç½² (Week 11-12)**
1. **ç”Ÿäº§ç¯å¢ƒå‡†å¤‡**
   - é…ç½®K8sç”Ÿäº§é›†ç¾¤
   - å»ºç«‹ç›‘æ§å‘Šè­¦
   - å‡†å¤‡ç¾å¤‡æ–¹æ¡ˆ

2. **ç°åº¦å‘å¸ƒ**
   - å°æ¯”ä¾‹æµé‡åˆ‡æ¢
   - ç›‘æ§ç³»ç»Ÿç¨³å®šæ€§
   - é€æ­¥å®Œå…¨åˆ‡æ¢

---

## ğŸ“Š æˆåŠŸæŒ‡æ ‡

### **æŠ€æœ¯æŒ‡æ ‡**
- **APIå“åº”æ—¶é—´**: < 100ms (P95)
- **ç³»ç»Ÿå¯ç”¨æ€§**: > 99.9%
- **æœåŠ¡å¯åŠ¨æ—¶é—´**: < 30ç§’
- **èµ„æºåˆ©ç”¨ç‡**: CPU < 70%, Memory < 80%

### **ä¸šåŠ¡æŒ‡æ ‡**
- **è®¢å•å¤„ç†å»¶è¿Ÿ**: < 50ms
- **ç­–ç•¥æ‰§è¡ŒæˆåŠŸç‡**: > 99.5%
- **é…ç½®æ›´æ–°ç”Ÿæ•ˆæ—¶é—´**: < 5ç§’
- **å¹¶å‘ç”¨æˆ·æ”¯æŒ**: > 10,000

### **è¿ç»´æŒ‡æ ‡**
- **éƒ¨ç½²æˆåŠŸç‡**: > 99%
- **æ•…éšœæ¢å¤æ—¶é—´**: < 5åˆ†é’Ÿ
- **ç›‘æ§è¦†ç›–ç‡**: > 95%
- **å‘Šè­¦å‡†ç¡®ç‡**: > 90%

---

## ğŸ¯ æ€»ç»“

### **æ¶æ„ä¼˜åŠ¿**
1. **ç®€å•ç›´è§‚**: èˆå¼ƒå¤æ‚DDDæ¶æ„ï¼Œé‡‡ç”¨ç›´æ¥çš„ä¸‰å±‚æ¶æ„
2. **é«˜åº¦è§£è€¦**: å¾®æœåŠ¡ç‹¬ç«‹éƒ¨ç½²ï¼ŒæœåŠ¡é—´æ¾è€¦åˆ
3. **å¯æ‰©å±•æ€§**: æ”¯æŒæ°´å¹³æ‰©å±•å’Œå¼¹æ€§ä¼¸ç¼©
4. **å¯è§‚æµ‹æ€§**: å®Œæ•´çš„ç›‘æ§ã€æ—¥å¿—ã€è¿½è¸ªä½“ç³»
5. **é«˜å¯ç”¨æ€§**: å¤šå‰¯æœ¬éƒ¨ç½²ï¼Œæ•…éšœè‡ªæ„ˆ

### **ä¸æ—§æ¶æ„å¯¹æ¯”**
| æ–¹é¢ | æ—§DDDæ¶æ„ | æ–°å¾®æœåŠ¡æ¶æ„ |
|------|-----------|--------------|
| å¤æ‚åº¦ | æé«˜ (9å±‚è°ƒç”¨) | ç®€å• (3å±‚) |
| å­¦ä¹ æˆæœ¬ | 2-3å‘¨ | 3-5å¤© |
| ç»´æŠ¤æˆæœ¬ | é«˜ | ä½ |
| æ€§èƒ½ | ä¸€èˆ¬ | ä¼˜ç§€ |
| æ‰©å±•æ€§ | å›°éš¾ | å®¹æ˜“ |
| éƒ¨ç½²å¤æ‚åº¦ | é«˜ | ä¸­ç­‰ |

### **é¢„æœŸæ”¶ç›Š**
- **å¼€å‘æ•ˆç‡**: æå‡200%
- **ç³»ç»Ÿæ€§èƒ½**: æå‡150%
- **ç»´æŠ¤æˆæœ¬**: é™ä½70%
- **æ•…éšœæ¢å¤**: æå‡300%

è¿™ä¸ªå¤–éƒ¨å¾®æœåŠ¡æ¶æ„å®Œå…¨èˆå¼ƒäº†å¤æ‚çš„DDDè®¾è®¡ï¼Œé‡‡ç”¨ç®€å•é«˜æ•ˆçš„æ–¹æ¡ˆï¼Œæ—¢ä¿è¯äº†ç³»ç»Ÿçš„åŠŸèƒ½å®Œæ•´æ€§ï¼Œåˆå¤§å¤§é™ä½äº†å¤æ‚åº¦å’Œç»´æŠ¤æˆæœ¬ã€‚
