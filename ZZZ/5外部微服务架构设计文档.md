# 🏗️ RedFire外部微服务架构设计文档

## 📋 设计概述

**设计目标**: 舍弃复杂DDD架构，建立简单高效的外部微服务架构  
**核心理念**: Simple First + Service Oriented + Cloud Native  
**架构模式**: 外部微服务 + 事件驱动 + API网关  
**实施策略**: 渐进式迁移，零停机切换

---

## 🎯 设计原则

### **1. Simple First (简单优先)**
- ❌ 舍弃DDD的复杂分层架构 (Domain/Application/Infrastructure)
- ❌ 移除过度抽象的CQRS模式
- ❌ 简化依赖注入的复杂生命周期管理
- ✅ 采用直接的三层架构: **API → Service → Repository**

### **2. Service Oriented (服务导向)**
- ✅ 按业务功能划分独立微服务
- ✅ 服务间通过标准HTTP API通信
- ✅ 每个服务独立部署和扩展
- ✅ 服务发现和负载均衡

### **3. Cloud Native (云原生)**
- ✅ 容器化部署 (Docker + Kubernetes)
- ✅ 服务网格架构 (Istio)
- ✅ 配置外部化管理
- ✅ 可观测性支持 (Metrics + Logs + Tracing)

---

## 🏗️ 整体架构设计

### **微服务架构全景图**

```mermaid
graph TB
    subgraph "外部客户端"
        Web[Web前端]
        Mobile[移动端]
        API_Client[API客户端]
    end
    
    subgraph "API网关层"
        Gateway[API Gateway]
        LB[负载均衡器]
    end
    
    subgraph "核心业务微服务"
        UserSvc[用户服务]
        TradingSvc[交易服务]
        StrategySvc[策略服务]
        MarketSvc[行情数据服务]
        RiskSvc[风险管理服务]
        NotifySvc[通知服务]
    end
    
    subgraph "基础设施微服务"
        ConfigSvc[配置管理服务]
        AuthSvc[认证授权服务]
        LogSvc[日志服务]
        MonitorSvc[监控服务]
    end
    
    subgraph "外部集成服务"
        VnPySvc[VnPy引擎服务]
        DataSvc[外部数据服务]
        PaymentSvc[支付服务]
    end
    
    subgraph "数据存储层"
        DB[(数据库集群)]
        Cache[(Redis集群)]
        MQ[(消息队列)]
        Storage[(对象存储)]
    end
    
    Web --> Gateway
    Mobile --> Gateway
    API_Client --> Gateway
    
    Gateway --> UserSvc
    Gateway --> TradingSvc
    Gateway --> StrategySvc
    Gateway --> MarketSvc
    
    UserSvc --> DB
    TradingSvc --> DB
    StrategySvc --> DB
    MarketSvc --> Cache
    
    UserSvc --> AuthSvc
    TradingSvc --> RiskSvc
    StrategySvc --> VnPySvc
    MarketSvc --> DataSvc
    
    ConfigSvc --> DB
    AuthSvc --> Cache
    LogSvc --> Storage
    MonitorSvc --> DB
```

---

## 🎯 核心微服务详细设计

### **1. 用户服务 (User Service)**

#### **职责范围**
- 用户注册、登录、认证
- 用户信息管理
- 用户权限控制
- 账户状态管理

#### **技术架构**
```python
# 简化的三层架构
用户服务/
├── api/
│   ├── auth_controller.py      # 认证控制器
│   ├── user_controller.py      # 用户控制器
│   └── profile_controller.py   # 资料控制器
├── services/
│   ├── auth_service.py         # 认证服务
│   ├── user_service.py         # 用户服务
│   └── profile_service.py      # 资料服务
├── repositories/
│   ├── user_repository.py      # 用户仓储
│   └── session_repository.py   # 会话仓储
├── models/
│   ├── user.py                 # 用户模型
│   └── session.py              # 会话模型
└── config/
    ├── database.py             # 数据库配置
    └── redis.py                # Redis配置
```

#### **核心API接口**
```python
# api/auth_controller.py
from fastapi import APIRouter, Depends, HTTPException
from services.auth_service import AuthService

router = APIRouter(prefix="/auth", tags=["认证"])

@router.post("/register")
async def register(
    user_data: UserRegisterRequest,
    auth_service: AuthService = Depends()
):
    """用户注册"""
    try:
        user = await auth_service.register(user_data)
        return {"success": True, "user_id": user.id}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/login")
async def login(
    credentials: LoginRequest,
    auth_service: AuthService = Depends()
):
    """用户登录"""
    try:
        token = await auth_service.login(credentials)
        return {"access_token": token, "token_type": "bearer"}
    except Exception as e:
        raise HTTPException(status_code=401, detail="Invalid credentials")

@router.post("/logout")
async def logout(
    token: str = Depends(get_current_token),
    auth_service: AuthService = Depends()
):
    """用户登出"""
    await auth_service.logout(token)
    return {"success": True}
```

#### **业务服务实现**
```python
# services/auth_service.py
from typing import Optional
import bcrypt
import jwt
from datetime import datetime, timedelta

class AuthService:
    def __init__(self, user_repo: UserRepository, session_repo: SessionRepository):
        self.user_repo = user_repo
        self.session_repo = session_repo
        self.secret_key = "your-secret-key"
    
    async def register(self, user_data: UserRegisterRequest) -> User:
        """用户注册"""
        # 检查用户是否已存在
        existing_user = await self.user_repo.get_by_email(user_data.email)
        if existing_user:
            raise ValueError("User already exists")
        
        # 密码加密
        hashed_password = bcrypt.hashpw(
            user_data.password.encode(), bcrypt.gensalt()
        )
        
        # 创建用户
        user = User(
            username=user_data.username,
            email=user_data.email,
            password_hash=hashed_password.decode(),
            is_active=True
        )
        
        return await self.user_repo.create(user)
    
    async def login(self, credentials: LoginRequest) -> str:
        """用户登录"""
        # 验证用户
        user = await self.user_repo.get_by_email(credentials.email)
        if not user or not user.is_active:
            raise ValueError("User not found or inactive")
        
        # 验证密码
        if not bcrypt.checkpw(
            credentials.password.encode(), 
            user.password_hash.encode()
        ):
            raise ValueError("Invalid password")
        
        # 生成JWT令牌
        payload = {
            "user_id": user.id,
            "email": user.email,
            "exp": datetime.utcnow() + timedelta(hours=24)
        }
        token = jwt.encode(payload, self.secret_key, algorithm="HS256")
        
        # 保存会话
        session = Session(
            user_id=user.id,
            token=token,
            expires_at=datetime.utcnow() + timedelta(hours=24)
        )
        await self.session_repo.create(session)
        
        return token
    
    async def logout(self, token: str):
        """用户登出"""
        session = await self.session_repo.get_by_token(token)
        if session:
            await self.session_repo.delete(session.id)
```

### **2. 交易服务 (Trading Service)**

#### **职责范围**
- 订单管理 (创建、修改、取消)
- 持仓管理
- 交易记录
- 资金管理

#### **技术架构**
```python
交易服务/
├── api/
│   ├── order_controller.py     # 订单控制器
│   ├── position_controller.py  # 持仓控制器
│   └── trade_controller.py     # 交易控制器
├── services/
│   ├── order_service.py        # 订单服务
│   ├── position_service.py     # 持仓服务
│   └── trade_service.py        # 交易服务
├── repositories/
│   ├── order_repository.py     # 订单仓储
│   ├── position_repository.py  # 持仓仓储
│   └── trade_repository.py     # 交易仓储
├── models/
│   ├── order.py               # 订单模型
│   ├── position.py            # 持仓模型
│   └── trade.py               # 交易模型
└── events/
    ├── order_events.py        # 订单事件
    └── trade_events.py        # 交易事件
```

#### **核心服务实现**
```python
# services/order_service.py
from typing import List, Optional
from models.order import Order, OrderStatus, OrderType
from events.order_events import OrderCreatedEvent, OrderFilledEvent

class OrderService:
    def __init__(self, order_repo: OrderRepository, event_bus: EventBus):
        self.order_repo = order_repo
        self.event_bus = event_bus
    
    async def create_order(self, order_data: CreateOrderRequest) -> Order:
        """创建订单"""
        # 创建订单对象
        order = Order(
            user_id=order_data.user_id,
            symbol=order_data.symbol,
            side=order_data.side,
            order_type=order_data.order_type,
            quantity=order_data.quantity,
            price=order_data.price,
            status=OrderStatus.PENDING
        )
        
        # 保存订单
        saved_order = await self.order_repo.create(order)
        
        # 发布订单创建事件
        event = OrderCreatedEvent(
            order_id=saved_order.id,
            user_id=saved_order.user_id,
            symbol=saved_order.symbol,
            quantity=saved_order.quantity,
            price=saved_order.price
        )
        await self.event_bus.publish(event)
        
        return saved_order
    
    async def cancel_order(self, order_id: str, user_id: str) -> bool:
        """取消订单"""
        order = await self.order_repo.get_by_id(order_id)
        if not order or order.user_id != user_id:
            raise ValueError("Order not found or access denied")
        
        if order.status not in [OrderStatus.PENDING, OrderStatus.PARTIAL_FILLED]:
            raise ValueError("Cannot cancel order in current status")
        
        # 更新订单状态
        order.status = OrderStatus.CANCELLED
        await self.order_repo.update(order)
        
        # 发布订单取消事件
        event = OrderCancelledEvent(order_id=order.id)
        await self.event_bus.publish(event)
        
        return True
    
    async def get_user_orders(
        self, 
        user_id: str, 
        status: Optional[OrderStatus] = None
    ) -> List[Order]:
        """获取用户订单"""
        return await self.order_repo.get_by_user_id(user_id, status)
```

### **3. 策略服务 (Strategy Service)**

#### **职责范围**
- 策略管理 (创建、启动、停止)
- 策略参数配置
- 策略运行状态监控
- 策略性能统计

#### **技术架构**
```python
策略服务/
├── api/
│   ├── strategy_controller.py   # 策略控制器
│   └── backtest_controller.py   # 回测控制器
├── services/
│   ├── strategy_service.py      # 策略服务
│   ├── backtest_service.py      # 回测服务
│   └── engine_service.py        # 引擎服务
├── engine/
│   ├── strategy_engine.py       # 策略引擎
│   ├── base_strategy.py         # 策略基类
│   └── indicators/              # 技术指标
├── repositories/
│   └── strategy_repository.py   # 策略仓储
└── models/
    ├── strategy.py              # 策略模型
    └── backtest.py              # 回测模型
```

#### **策略引擎实现**
```python
# engine/strategy_engine.py
from typing import Dict, List
import asyncio
from abc import ABC, abstractmethod

class StrategyEngine:
    def __init__(self):
        self.strategies: Dict[str, BaseStrategy] = {}
        self.running = False
        self.market_data_subscriber = None
    
    async def add_strategy(self, strategy_id: str, strategy: 'BaseStrategy'):
        """添加策略"""
        self.strategies[strategy_id] = strategy
        await strategy.initialize()
        
    async def start_strategy(self, strategy_id: str):
        """启动策略"""
        if strategy_id not in self.strategies:
            raise ValueError(f"Strategy {strategy_id} not found")
        
        strategy = self.strategies[strategy_id]
        await strategy.start()
        
    async def stop_strategy(self, strategy_id: str):
        """停止策略"""
        if strategy_id not in self.strategies:
            raise ValueError(f"Strategy {strategy_id} not found")
        
        strategy = self.strategies[strategy_id]
        await strategy.stop()
    
    async def on_market_data(self, market_data: MarketData):
        """处理市场数据"""
        for strategy in self.strategies.values():
            if strategy.is_running():
                await strategy.on_tick(market_data)

class BaseStrategy(ABC):
    def __init__(self, strategy_id: str, config: Dict):
        self.strategy_id = strategy_id
        self.config = config
        self.running = False
        self.positions = {}
        self.orders = {}
    
    @abstractmethod
    async def initialize(self):
        """策略初始化"""
        pass
    
    @abstractmethod
    async def on_tick(self, market_data: MarketData):
        """处理市场数据"""
        pass
    
    async def start(self):
        """启动策略"""
        self.running = True
        
    async def stop(self):
        """停止策略"""
        self.running = False
    
    def is_running(self) -> bool:
        """检查策略是否运行中"""
        return self.running
    
    async def buy(self, symbol: str, quantity: float, price: float = None):
        """买入"""
        order_data = {
            "symbol": symbol,
            "side": "buy",
            "quantity": quantity,
            "price": price,
            "order_type": "market" if price is None else "limit"
        }
        # 发送到交易服务
        await self._send_order(order_data)
    
    async def sell(self, symbol: str, quantity: float, price: float = None):
        """卖出"""
        order_data = {
            "symbol": symbol,
            "side": "sell", 
            "quantity": quantity,
            "price": price,
            "order_type": "market" if price is None else "limit"
        }
        # 发送到交易服务
        await self._send_order(order_data)
    
    async def _send_order(self, order_data: Dict):
        """发送订单到交易服务"""
        # 通过HTTP API调用交易服务
        pass
```

### **4. 配置管理服务 (Configuration Service)**

#### **职责范围**
- 集中式配置管理
- 多环境配置隔离
- 配置热更新
- 配置版本控制

#### **技术架构**
```python
配置服务/
├── api/
│   ├── config_controller.py    # 配置控制器
│   └── env_controller.py       # 环境控制器
├── services/
│   ├── config_service.py       # 配置服务
│   ├── validation_service.py   # 验证服务
│   └── notification_service.py # 通知服务
├── repositories/
│   ├── config_repository.py    # 配置仓储
│   └── version_repository.py   # 版本仓储
├── models/
│   ├── config.py              # 配置模型
│   └── version.py             # 版本模型
└── watchers/
    └── config_watcher.py      # 配置监听器
```

#### **配置服务实现**
```python
# services/config_service.py
from typing import Dict, Any, Optional
import json
import asyncio
from models.config import Config
from events.config_events import ConfigChangedEvent

class ConfigService:
    def __init__(self, config_repo: ConfigRepository, event_bus: EventBus):
        self.config_repo = config_repo
        self.event_bus = event_bus
        self.cache = {}
    
    async def get_config(
        self, 
        service_name: str, 
        key: str, 
        environment: str = "production"
    ) -> Any:
        """获取配置值"""
        cache_key = f"{service_name}:{key}:{environment}"
        
        # 检查缓存
        if cache_key in self.cache:
            return self.cache[cache_key]
        
        # 从数据库获取
        config = await self.config_repo.get_config(service_name, key, environment)
        if config:
            self.cache[cache_key] = config.value
            return config.value
        
        return None
    
    async def set_config(
        self,
        service_name: str,
        key: str,
        value: Any,
        environment: str = "production",
        changed_by: str = "system"
    ) -> Config:
        """设置配置值"""
        # 获取旧值
        old_value = await self.get_config(service_name, key, environment)
        
        # 创建或更新配置
        config = Config(
            service_name=service_name,
            key=key,
            value=value,
            environment=environment,
            changed_by=changed_by
        )
        
        saved_config = await self.config_repo.save(config)
        
        # 更新缓存
        cache_key = f"{service_name}:{key}:{environment}"
        self.cache[cache_key] = value
        
        # 发布配置变更事件
        event = ConfigChangedEvent(
            service_name=service_name,
            key=key,
            old_value=old_value,
            new_value=value,
            environment=environment,
            changed_by=changed_by
        )
        await self.event_bus.publish(event)
        
        return saved_config
    
    async def get_service_configs(
        self, 
        service_name: str, 
        environment: str = "production"
    ) -> Dict[str, Any]:
        """获取服务的所有配置"""
        configs = await self.config_repo.get_service_configs(service_name, environment)
        return {config.key: config.value for config in configs}
    
    async def subscribe_to_changes(
        self, 
        service_name: str, 
        callback: callable,
        environment: str = "production"
    ):
        """订阅配置变更"""
        # 注册回调函数
        await self.event_bus.subscribe(
            f"config_changed:{service_name}:{environment}",
            callback
        )
```

---

## 🌐 服务间通信设计

### **1. 同步通信 (HTTP API)**

#### **API网关路由配置**
```yaml
# api-gateway.yaml
routes:
  # 用户服务路由
  - path: /api/users/*
    service: user-service
    port: 8001
    health_check: /health
    
  # 交易服务路由  
  - path: /api/trading/*
    service: trading-service
    port: 8002
    health_check: /health
    
  # 策略服务路由
  - path: /api/strategies/*
    service: strategy-service
    port: 8003
    health_check: /health
    
  # 配置服务路由
  - path: /api/config/*
    service: config-service
    port: 8004
    health_check: /health

middleware:
  - name: authentication
    config:
      jwt_secret: ${JWT_SECRET}
      exclude_paths: ["/api/users/register", "/api/users/login"]
      
  - name: rate_limiting
    config:
      requests_per_minute: 1000
      
  - name: cors
    config:
      allowed_origins: ["http://localhost:3000"]
      allowed_methods: ["GET", "POST", "PUT", "DELETE"]
```

#### **服务发现配置**
```python
# service_discovery.py
import consul
from typing import Dict, List

class ServiceDiscovery:
    def __init__(self, consul_host: str = "localhost", consul_port: int = 8500):
        self.consul = consul.Consul(host=consul_host, port=consul_port)
    
    async def register_service(
        self, 
        service_name: str, 
        service_id: str,
        host: str, 
        port: int,
        health_check_url: str
    ):
        """注册服务"""
        self.consul.agent.service.register(
            name=service_name,
            service_id=service_id,
            address=host,
            port=port,
            check=consul.Check.http(health_check_url, interval="10s")
        )
    
    async def discover_service(self, service_name: str) -> List[Dict]:
        """发现服务"""
        _, services = self.consul.health.service(service_name, passing=True)
        return [
            {
                "host": service["Service"]["Address"],
                "port": service["Service"]["Port"]
            }
            for service in services
        ]
    
    async def deregister_service(self, service_id: str):
        """注销服务"""
        self.consul.agent.service.deregister(service_id)
```

### **2. 异步通信 (消息队列)**

#### **事件总线设计**
```python
# event_bus.py
import asyncio
import json
from typing import Dict, List, Callable
from abc import ABC, abstractmethod
import aio_pika

class Event(ABC):
    @abstractmethod
    def to_dict(self) -> Dict:
        pass
    
    @classmethod
    @abstractmethod 
    def from_dict(cls, data: Dict):
        pass

class OrderCreatedEvent(Event):
    def __init__(self, order_id: str, user_id: str, symbol: str, quantity: float):
        self.order_id = order_id
        self.user_id = user_id
        self.symbol = symbol
        self.quantity = quantity
        self.event_type = "order_created"
    
    def to_dict(self) -> Dict:
        return {
            "event_type": self.event_type,
            "order_id": self.order_id,
            "user_id": self.user_id,
            "symbol": self.symbol,
            "quantity": self.quantity
        }
    
    @classmethod
    def from_dict(cls, data: Dict):
        return cls(
            order_id=data["order_id"],
            user_id=data["user_id"],
            symbol=data["symbol"],
            quantity=data["quantity"]
        )

class EventBus:
    def __init__(self, rabbitmq_url: str):
        self.rabbitmq_url = rabbitmq_url
        self.connection = None
        self.channel = None
        self.subscribers: Dict[str, List[Callable]] = {}
    
    async def connect(self):
        """连接消息队列"""
        self.connection = await aio_pika.connect_robust(self.rabbitmq_url)
        self.channel = await self.connection.channel()
    
    async def publish(self, event: Event, routing_key: str = None):
        """发布事件"""
        if not self.channel:
            await self.connect()
        
        routing_key = routing_key or event.event_type
        exchange = await self.channel.declare_exchange(
            "events", aio_pika.ExchangeType.TOPIC
        )
        
        message = aio_pika.Message(
            json.dumps(event.to_dict()).encode(),
            content_type="application/json"
        )
        
        await exchange.publish(message, routing_key=routing_key)
    
    async def subscribe(self, event_pattern: str, callback: Callable):
        """订阅事件"""
        if not self.channel:
            await self.connect()
        
        exchange = await self.channel.declare_exchange(
            "events", aio_pika.ExchangeType.TOPIC
        )
        
        queue = await self.channel.declare_queue("", exclusive=True)
        await queue.bind(exchange, routing_key=event_pattern)
        
        async def message_handler(message: aio_pika.IncomingMessage):
            async with message.process():
                try:
                    data = json.loads(message.body.decode())
                    await callback(data)
                except Exception as e:
                    logger.error(f"Error processing message: {e}")
        
        await queue.consume(message_handler)
```

---

## 📊 数据管理设计

### **1. 数据库架构**

#### **数据库分布策略**
```yaml
# 数据库分布设计
数据库分布:
  用户服务:
    数据库: user_db
    表: [users, sessions, profiles]
    分片策略: 按user_id分片
    
  交易服务:
    数据库: trading_db  
    表: [orders, trades, positions, accounts]
    分片策略: 按user_id + 时间分片
    
  策略服务:
    数据库: strategy_db
    表: [strategies, backtests, parameters]
    分片策略: 按user_id分片
    
  配置服务:
    数据库: config_db
    表: [configs, versions, environments]
    分片策略: 按service_name分片
    
  行情数据:
    数据库: market_db (InfluxDB)
    表: [ticks, bars, indicators]
    分片策略: 按symbol + 时间分片
```

#### **数据模型设计**
```python
# models/user.py
from sqlalchemy import Column, String, Integer, DateTime, Boolean
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    
    id = Column(String(36), primary_key=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    password_hash = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, nullable=False)
    updated_at = Column(DateTime)

# models/order.py
class Order(Base):
    __tablename__ = "orders"
    
    id = Column(String(36), primary_key=True)
    user_id = Column(String(36), nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    side = Column(String(4), nullable=False)  # BUY/SELL
    order_type = Column(String(10), nullable=False)  # MARKET/LIMIT
    quantity = Column(Integer, nullable=False)
    price = Column(String(20))  # 使用字符串存储精确价格
    status = Column(String(20), nullable=False, index=True)
    created_at = Column(DateTime, nullable=False, index=True)
    updated_at = Column(DateTime)

# models/strategy.py  
class Strategy(Base):
    __tablename__ = "strategies"
    
    id = Column(String(36), primary_key=True)
    user_id = Column(String(36), nullable=False, index=True)
    name = Column(String(100), nullable=False)
    class_name = Column(String(100), nullable=False)
    symbol = Column(String(20), nullable=False)
    parameters = Column(String(2000))  # JSON格式参数
    status = Column(String(20), nullable=False, index=True)
    created_at = Column(DateTime, nullable=False)
    updated_at = Column(DateTime)
```

### **2. 缓存设计**

#### **多级缓存架构**
```python
# cache/multi_level_cache.py
from typing import Any, Optional
import json
import asyncio
import redis.asyncio as redis

class MultiLevelCache:
    def __init__(self, redis_url: str):
        self.l1_cache = {}  # 本地内存缓存
        self.l2_cache = redis.from_url(redis_url)  # Redis缓存
        self.lock = asyncio.Lock()
    
    async def get(self, key: str) -> Optional[Any]:
        """获取缓存 - L1 -> L2 -> None"""
        # L1缓存查找
        if key in self.l1_cache:
            return self.l1_cache[key]
        
        # L2缓存查找
        try:
            value = await self.l2_cache.get(key)
            if value:
                decoded_value = json.loads(value)
                # 回填L1缓存
                self.l1_cache[key] = decoded_value
                return decoded_value
        except Exception as e:
            logger.error(f"Redis cache error: {e}")
        
        return None
    
    async def set(self, key: str, value: Any, ttl: int = 3600):
        """设置缓存 - L1 + L2"""
        async with self.lock:
            # 设置L1缓存
            self.l1_cache[key] = value
            
            # 设置L2缓存
            try:
                await self.l2_cache.setex(key, ttl, json.dumps(value, default=str))
            except Exception as e:
                logger.error(f"Redis cache set error: {e}")
    
    async def delete(self, key: str):
        """删除缓存"""
        # 删除L1缓存
        self.l1_cache.pop(key, None)
        
        # 删除L2缓存
        try:
            await self.l2_cache.delete(key)
        except Exception as e:
            logger.error(f"Redis cache delete error: {e}")
    
    async def invalidate_pattern(self, pattern: str):
        """按模式失效缓存"""
        # 清空L1缓存中匹配的键
        keys_to_remove = [k for k in self.l1_cache.keys() if pattern in k]
        for key in keys_to_remove:
            del self.l1_cache[key]
        
        # 清空L2缓存中匹配的键
        try:
            keys = await self.l2_cache.keys(pattern)
            if keys:
                await self.l2_cache.delete(*keys)
        except Exception as e:
            logger.error(f"Redis pattern delete error: {e}")
```

---

## 🔒 安全设计

### **1. 认证授权架构**

#### **JWT认证实现**
```python
# security/jwt_auth.py
import jwt
from datetime import datetime, timedelta
from typing import Optional, Dict
from fastapi import HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

security = HTTPBearer()

class JWTManager:
    def __init__(self, secret_key: str, algorithm: str = "HS256"):
        self.secret_key = secret_key
        self.algorithm = algorithm
        self.access_token_expire = timedelta(hours=24)
        self.refresh_token_expire = timedelta(days=30)
    
    def create_access_token(self, data: Dict) -> str:
        """创建访问令牌"""
        to_encode = data.copy()
        expire = datetime.utcnow() + self.access_token_expire
        to_encode.update({"exp": expire, "type": "access"})
        
        return jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
    
    def create_refresh_token(self, data: Dict) -> str:
        """创建刷新令牌"""
        to_encode = data.copy()
        expire = datetime.utcnow() + self.refresh_token_expire
        to_encode.update({"exp": expire, "type": "refresh"})
        
        return jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
    
    def verify_token(self, token: str) -> Optional[Dict]:
        """验证令牌"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(status_code=401, detail="Token expired")
        except jwt.JWTError:
            raise HTTPException(status_code=401, detail="Invalid token")

# 依赖注入函数
async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    jwt_manager: JWTManager = Depends()
) -> Dict:
    """获取当前用户"""
    token = credentials.credentials
    payload = jwt_manager.verify_token(token)
    
    if payload.get("type") != "access":
        raise HTTPException(status_code=401, detail="Invalid token type")
    
    return payload
```

#### **权限控制实现**
```python
# security/rbac.py
from enum import Enum
from typing import List, Set
from functools import wraps
from fastapi import HTTPException

class Permission(Enum):
    # 用户权限
    USER_READ = "user:read"
    USER_WRITE = "user:write"
    USER_DELETE = "user:delete"
    
    # 交易权限
    TRADING_READ = "trading:read"
    TRADING_WRITE = "trading:write"
    TRADING_DELETE = "trading:delete"
    
    # 策略权限
    STRATEGY_READ = "strategy:read"
    STRATEGY_WRITE = "strategy:write"
    STRATEGY_DELETE = "strategy:delete"
    
    # 管理员权限
    ADMIN_ALL = "admin:all"

class Role(Enum):
    GUEST = "guest"
    USER = "user"
    TRADER = "trader"
    ADMIN = "admin"

# 角色权限映射
ROLE_PERMISSIONS = {
    Role.GUEST: [Permission.USER_READ],
    Role.USER: [
        Permission.USER_READ, Permission.USER_WRITE,
        Permission.TRADING_READ, Permission.STRATEGY_READ
    ],
    Role.TRADER: [
        Permission.USER_READ, Permission.USER_WRITE,
        Permission.TRADING_READ, Permission.TRADING_WRITE,
        Permission.STRATEGY_READ, Permission.STRATEGY_WRITE
    ],
    Role.ADMIN: [Permission.ADMIN_ALL]
}

def require_permission(permission: Permission):
    """权限装饰器"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # 从请求中获取用户信息
            user = kwargs.get('current_user')
            if not user:
                raise HTTPException(status_code=401, detail="Authentication required")
            
            # 检查权限
            user_role = Role(user.get('role', 'guest'))
            user_permissions = ROLE_PERMISSIONS.get(user_role, [])
            
            if Permission.ADMIN_ALL in user_permissions or permission in user_permissions:
                return await func(*args, **kwargs)
            else:
                raise HTTPException(status_code=403, detail="Insufficient permissions")
        
        return wrapper
    return decorator

# 使用示例
@require_permission(Permission.TRADING_WRITE)
async def create_order(order_data: CreateOrderRequest, current_user: Dict = Depends(get_current_user)):
    """创建订单 - 需要交易写权限"""
    pass
```

### **2. API安全增强**

#### **速率限制实现**
```python
# security/rate_limiter.py
import time
from typing import Dict, Tuple
from fastapi import HTTPException, Request
import redis.asyncio as redis

class RateLimiter:
    def __init__(self, redis_url: str):
        self.redis = redis.from_url(redis_url)
        self.rules = {
            "default": {"requests": 100, "window": 60},  # 100次/分钟
            "auth": {"requests": 10, "window": 60},      # 10次/分钟  
            "trading": {"requests": 300, "window": 60},  # 300次/分钟
        }
    
    async def is_allowed(self, key: str, rule_name: str = "default") -> Tuple[bool, Dict]:
        """检查是否允许请求"""
        rule = self.rules.get(rule_name, self.rules["default"])
        window = rule["window"]
        limit = rule["requests"]
        
        current_time = int(time.time())
        window_start = current_time - window
        
        # 使用Redis滑动窗口算法
        pipe = self.redis.pipeline()
        
        # 移除过期的记录
        pipe.zremrangebyscore(key, 0, window_start)
        
        # 添加当前请求
        pipe.zadd(key, {str(current_time): current_time})
        
        # 获取当前窗口内的请求数
        pipe.zcard(key)
        
        # 设置过期时间
        pipe.expire(key, window)
        
        results = await pipe.execute()
        request_count = results[2]
        
        allowed = request_count <= limit
        remaining = max(0, limit - request_count)
        
        return allowed, {
            "limit": limit,
            "remaining": remaining,
            "reset_time": current_time + window
        }

async def rate_limit_middleware(request: Request, call_next):
    """速率限制中间件"""
    # 获取客户端标识
    client_ip = request.client.host
    endpoint = request.url.path
    
    # 确定限流规则
    rule_name = "default"
    if "/auth/" in endpoint:
        rule_name = "auth"
    elif "/trading/" in endpoint:
        rule_name = "trading"
    
    # 检查速率限制
    limiter = RateLimiter("redis://localhost:6379")
    key = f"rate_limit:{client_ip}:{rule_name}"
    
    allowed, info = await limiter.is_allowed(key, rule_name)
    
    if not allowed:
        raise HTTPException(
            status_code=429, 
            detail="Rate limit exceeded",
            headers={
                "X-RateLimit-Limit": str(info["limit"]),
                "X-RateLimit-Remaining": str(info["remaining"]),
                "X-RateLimit-Reset": str(info["reset_time"])
            }
        )
    
    response = await call_next(request)
    
    # 添加速率限制头部
    response.headers["X-RateLimit-Limit"] = str(info["limit"])
    response.headers["X-RateLimit-Remaining"] = str(info["remaining"])
    response.headers["X-RateLimit-Reset"] = str(info["reset_time"])
    
    return response
```

---

## 📊 监控与可观测性

### **1. 指标收集**

#### **Prometheus指标定义**
```python
# monitoring/metrics.py
from prometheus_client import Counter, Histogram, Gauge, Info
import time
from functools import wraps

# 业务指标
orders_total = Counter('orders_total', 'Total orders', ['service', 'status', 'symbol'])
order_processing_time = Histogram('order_processing_seconds', 'Order processing time', ['service'])
active_strategies = Gauge('active_strategies', 'Number of active strategies', ['service'])
user_sessions = Gauge('user_sessions', 'Number of active user sessions')

# 技术指标
http_requests_total = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint', 'status'])
http_request_duration = Histogram('http_request_duration_seconds', 'HTTP request duration')
database_connections = Gauge('database_connections', 'Database connections', ['service', 'status'])
cache_operations = Counter('cache_operations_total', 'Cache operations', ['service', 'operation', 'result'])

# 系统指标
service_info = Info('service_info', 'Service information')
service_up = Gauge('service_up', 'Service up status', ['service'])

class MetricsCollector:
    @staticmethod
    def record_order(service: str, status: str, symbol: str, processing_time: float):
        """记录订单指标"""
        orders_total.labels(service=service, status=status, symbol=symbol).inc()
        order_processing_time.labels(service=service).observe(processing_time)
    
    @staticmethod
    def record_http_request(method: str, endpoint: str, status: int, duration: float):
        """记录HTTP请求指标"""
        http_requests_total.labels(method=method, endpoint=endpoint, status=status).inc()
        http_request_duration.observe(duration)
    
    @staticmethod
    def set_active_strategies(service: str, count: int):
        """设置活跃策略数量"""
        active_strategies.labels(service=service).set(count)
    
    @staticmethod
    def record_cache_operation(service: str, operation: str, result: str):
        """记录缓存操作"""
        cache_operations.labels(service=service, operation=operation, result=result).inc()

def monitor_performance(metric_name: str = None):
    """性能监控装饰器"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = await func(*args, **kwargs)
                duration = time.time() - start_time
                
                # 记录成功指标
                if metric_name:
                    globals()[metric_name].observe(duration)
                
                return result
            except Exception as e:
                duration = time.time() - start_time
                # 记录失败指标
                logger.error(f"{func.__name__} failed after {duration:.4f}s: {e}")
                raise
        return wrapper
    return decorator
```

### **2. 日志聚合**

#### **结构化日志实现**
```python
# monitoring/structured_logging.py
import json
import logging
from datetime import datetime
from typing import Dict, Any
import traceback

class StructuredLogger:
    def __init__(self, service_name: str, version: str):
        self.service_name = service_name
        self.version = version
        self.logger = logging.getLogger(service_name)
        self.logger.setLevel(logging.INFO)
        
        # 配置JSON格式输出
        handler = logging.StreamHandler()
        handler.setFormatter(JSONFormatter())
        self.logger.addHandler(handler)
    
    def info(self, message: str, extra: Dict[str, Any] = None, **kwargs):
        """记录信息日志"""
        self._log("INFO", message, extra, **kwargs)
    
    def error(self, message: str, exception: Exception = None, extra: Dict[str, Any] = None, **kwargs):
        """记录错误日志"""
        log_data = extra or {}
        if exception:
            log_data.update({
                "exception_type": type(exception).__name__,
                "exception_message": str(exception),
                "traceback": traceback.format_exc()
            })
        self._log("ERROR", message, log_data, **kwargs)
    
    def warning(self, message: str, extra: Dict[str, Any] = None, **kwargs):
        """记录警告日志"""
        self._log("WARNING", message, extra, **kwargs)
    
    def _log(self, level: str, message: str, extra: Dict[str, Any] = None, **kwargs):
        """内部日志方法"""
        log_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": level,
            "service": self.service_name,
            "version": self.version,
            "message": message,
            **kwargs
        }
        
        if extra:
            log_data.update(extra)
        
        getattr(self.logger, level.lower())(json.dumps(log_data))

class JSONFormatter(logging.Formatter):
    def format(self, record):
        # 如果已经是JSON格式，直接返回
        if hasattr(record, 'getMessage'):
            try:
                json.loads(record.getMessage())
                return record.getMessage()
            except:
                pass
        
        # 否则格式化为JSON
        log_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": record.levelname,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno
        }
        
        return json.dumps(log_data)

# 使用示例
logger = StructuredLogger("trading-service", "1.0.0")

async def create_order(order_data: Dict):
    logger.info(
        "Order creation started",
        extra={
            "user_id": order_data["user_id"],
            "symbol": order_data["symbol"],
            "quantity": order_data["quantity"]
        },
        correlation_id="12345",
        request_id="req_67890"
    )
    
    try:
        # 订单处理逻辑
        result = await process_order(order_data)
        
        logger.info(
            "Order created successfully",
            extra={
                "order_id": result["order_id"],
                "status": result["status"]
            },
            correlation_id="12345",
            request_id="req_67890"
        )
        
        return result
    except Exception as e:
        logger.error(
            "Order creation failed",
            exception=e,
            extra={
                "user_id": order_data["user_id"],
                "symbol": order_data["symbol"]
            },
            correlation_id="12345",
            request_id="req_67890"
        )
        raise
```

### **3. 链路追踪**

#### **分布式追踪实现**
```python
# monitoring/tracing.py
import uuid
from typing import Optional, Dict
import asyncio
from contextvars import ContextVar
from functools import wraps

# 上下文变量
trace_context: ContextVar[Optional[Dict]] = ContextVar('trace_context', default=None)

class TraceContext:
    def __init__(self, trace_id: str = None, span_id: str = None, parent_span_id: str = None):
        self.trace_id = trace_id or str(uuid.uuid4())
        self.span_id = span_id or str(uuid.uuid4())
        self.parent_span_id = parent_span_id
        self.start_time = asyncio.get_event_loop().time()
        self.tags = {}
        self.logs = []
    
    def add_tag(self, key: str, value: str):
        """添加标签"""
        self.tags[key] = value
    
    def log(self, message: str, **kwargs):
        """添加日志"""
        self.logs.append({
            "timestamp": asyncio.get_event_loop().time(),
            "message": message,
            **kwargs
        })
    
    def finish(self):
        """结束span"""
        self.end_time = asyncio.get_event_loop().time()
        self.duration = self.end_time - self.start_time
        
        # 发送到追踪系统 (Jaeger/Zipkin)
        self._send_to_tracer()
    
    def _send_to_tracer(self):
        """发送追踪数据"""
        span_data = {
            "trace_id": self.trace_id,
            "span_id": self.span_id,
            "parent_span_id": self.parent_span_id,
            "start_time": self.start_time,
            "duration": self.duration,
            "tags": self.tags,
            "logs": self.logs
        }
        # 实际发送到Jaeger等追踪系统
        # jaeger_client.send_span(span_data)

def trace_async(operation_name: str = None):
    """异步追踪装饰器"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # 获取父上下文
            parent_context = trace_context.get()
            
            # 创建新的span
            span = TraceContext(
                trace_id=parent_context.trace_id if parent_context else None,
                parent_span_id=parent_context.span_id if parent_context else None
            )
            
            span.add_tag("operation", operation_name or func.__name__)
            span.add_tag("function", f"{func.__module__}.{func.__name__}")
            
            # 设置上下文
            trace_context.set(span)
            
            try:
                result = await func(*args, **kwargs)
                span.add_tag("status", "success")
                return result
            except Exception as e:
                span.add_tag("status", "error")
                span.add_tag("error.message", str(e))
                span.log("Exception occurred", exception=str(e))
                raise
            finally:
                span.finish()
        
        return wrapper
    return decorator

# HTTP中间件支持
async def tracing_middleware(request, call_next):
    """追踪中间件"""
    # 从请求头获取追踪信息
    trace_id = request.headers.get("X-Trace-Id")
    span_id = request.headers.get("X-Span-Id")
    
    # 创建span
    span = TraceContext(trace_id=trace_id, parent_span_id=span_id)
    span.add_tag("http.method", request.method)
    span.add_tag("http.url", str(request.url))
    span.add_tag("http.user_agent", request.headers.get("user-agent", ""))
    
    # 设置上下文
    trace_context.set(span)
    
    try:
        response = await call_next(request)
        span.add_tag("http.status_code", response.status_code)
        
        # 传递追踪信息到响应
        response.headers["X-Trace-Id"] = span.trace_id
        response.headers["X-Span-Id"] = span.span_id
        
        return response
    except Exception as e:
        span.add_tag("http.status_code", 500)
        span.add_tag("error", "true")
        span.log("Request failed", exception=str(e))
        raise
    finally:
        span.finish()

# 使用示例
@trace_async("create_order")
async def create_order(order_data: Dict):
    span = trace_context.get()
    span.add_tag("user_id", order_data["user_id"])
    span.add_tag("symbol", order_data["symbol"])
    span.log("Order creation started")
    
    # 业务逻辑
    result = await process_order(order_data)
    
    span.log("Order created", order_id=result["order_id"])
    return result
```

---

## 🚀 部署架构

### **1. 容器化部署**

#### **Docker Compose配置**
```yaml
# docker-compose.yml
version: '3.8'

services:
  # API网关
  api-gateway:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - user-service
      - trading-service
      - strategy-service
      - config-service
    networks:
      - redfire-network

  # 用户服务
  user-service:
    build:
      context: ./services/user-service
      dockerfile: Dockerfile
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/user_db
      - REDIS_URL=redis://redis:6379/0
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - postgres
      - redis
    networks:
      - redfire-network
    deploy:
      replicas: 3

  # 交易服务
  trading-service:
    build:
      context: ./services/trading-service
      dockerfile: Dockerfile
    environment:
      - DATABASE_URL=postgresql://trading:password@postgres:5432/trading_db
      - REDIS_URL=redis://redis:6379/1
      - RABBITMQ_URL=amqp://rabbitmq:5672
    depends_on:
      - postgres
      - redis
      - rabbitmq
    networks:
      - redfire-network
    deploy:
      replicas: 3

  # 策略服务
  strategy-service:
    build:
      context: ./services/strategy-service
      dockerfile: Dockerfile
    environment:
      - DATABASE_URL=postgresql://strategy:password@postgres:5432/strategy_db
      - REDIS_URL=redis://redis:6379/2
      - VNPY_SERVICE_URL=http://vnpy-service:8005
    depends_on:
      - postgres
      - redis
      - vnpy-service
    networks:
      - redfire-network
    deploy:
      replicas: 2

  # 配置服务
  config-service:
    build:
      context: ./services/config-service
      dockerfile: Dockerfile
    environment:
      - DATABASE_URL=postgresql://config:password@postgres:5432/config_db
      - REDIS_URL=redis://redis:6379/3
    depends_on:
      - postgres
      - redis
    networks:
      - redfire-network
    deploy:
      replicas: 2

  # VnPy引擎服务
  vnpy-service:
    build:
      context: ./services/vnpy-service
      dockerfile: Dockerfile
    environment:
      - CONFIG_SERVICE_URL=http://config-service:8004
    volumes:
      - ./vnpy_data:/app/data
    networks:
      - redfire-network
    deploy:
      replicas: 1

  # 数据库
  postgres:
    image: postgres:13
    environment:
      - POSTGRES_MULTIPLE_DATABASES=user_db,trading_db,strategy_db,config_db
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-db.sh:/docker-entrypoint-initdb.d/init-db.sh
    networks:
      - redfire-network

  # Redis
  redis:
    image: redis:6-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    networks:
      - redfire-network

  # 消息队列
  rabbitmq:
    image: rabbitmq:3-management
    environment:
      - RABBITMQ_DEFAULT_USER=redfire
      - RABBITMQ_DEFAULT_PASS=${RABBITMQ_PASSWORD}
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    ports:
      - "15672:15672"  # 管理界面
    networks:
      - redfire-network

  # 监控服务
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    networks:
      - redfire-network

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana:/etc/grafana/provisioning
    networks:
      - redfire-network

volumes:
  postgres_data:
  redis_data:
  rabbitmq_data:
  prometheus_data:
  grafana_data:

networks:
  redfire-network:
    driver: bridge
```

### **2. Kubernetes部署**

#### **K8s部署配置**
```yaml
# k8s/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: redfire

---
# k8s/user-service.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
  namespace: redfire
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: redfire/user-service:latest
        ports:
        - containerPort: 8001
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secrets
              key: user-db-url
        - name: REDIS_URL
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: redis-url
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: auth-secrets
              key: jwt-secret
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8001
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8001
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: user-service
  namespace: redfire
spec:
  selector:
    app: user-service
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8001
  type: ClusterIP

---
# k8s/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: redfire-ingress
  namespace: redfire
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - api.redfire.com
    secretName: redfire-tls
  rules:
  - host: api.redfire.com
    http:
      paths:
      - path: /api/users
        pathType: Prefix
        backend:
          service:
            name: user-service
            port:
              number: 80
      - path: /api/trading
        pathType: Prefix
        backend:
          service:
            name: trading-service
            port:
              number: 80
      - path: /api/strategies
        pathType: Prefix
        backend:
          service:
            name: strategy-service
            port:
              number: 80
      - path: /api/config
        pathType: Prefix
        backend:
          service:
            name: config-service
            port:
              number: 80

---
# k8s/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: user-service-hpa
  namespace: redfire
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: user-service
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

---

## 📋 迁移实施计划

### **阶段1: 基础设施准备 (Week 1-2)**
1. **容器化现有服务**
   - 为每个服务创建Dockerfile
   - 配置Docker Compose环境
   - 建立CI/CD流水线

2. **部署基础组件**
   - 部署PostgreSQL集群
   - 部署Redis集群
   - 部署RabbitMQ
   - 配置监控组件

### **阶段2: 配置服务迁移 (Week 3-4)**
1. **实现配置微服务**
   - 开发配置管理API
   - 实现配置推送机制
   - 建立配置版本控制

2. **迁移现有配置**
   - 分析现有配置文件
   - 批量导入到配置服务
   - 验证配置一致性

### **阶段3: 核心服务拆分 (Week 5-8)**
1. **用户服务独立**
   - 提取用户相关功能
   - 实现独立的用户数据库
   - 建立JWT认证机制

2. **交易服务独立**
   - 提取交易相关功能
   - 实现订单和持仓管理
   - 集成风险控制

3. **策略服务独立**
   - 提取策略相关功能
   - 实现策略引擎
   - 集成VnPy接口

### **阶段4: 服务集成与测试 (Week 9-10)**
1. **服务间通信**
   - 配置API网关
   - 实现服务发现
   - 建立事件总线

2. **端到端测试**
   - 功能完整性测试
   - 性能压力测试
   - 安全渗透测试

### **阶段5: 生产部署 (Week 11-12)**
1. **生产环境准备**
   - 配置K8s生产集群
   - 建立监控告警
   - 准备灾备方案

2. **灰度发布**
   - 小比例流量切换
   - 监控系统稳定性
   - 逐步完全切换

---

## 📊 成功指标

### **技术指标**
- **API响应时间**: < 100ms (P95)
- **系统可用性**: > 99.9%
- **服务启动时间**: < 30秒
- **资源利用率**: CPU < 70%, Memory < 80%

### **业务指标**
- **订单处理延迟**: < 50ms
- **策略执行成功率**: > 99.5%
- **配置更新生效时间**: < 5秒
- **并发用户支持**: > 10,000

### **运维指标**
- **部署成功率**: > 99%
- **故障恢复时间**: < 5分钟
- **监控覆盖率**: > 95%
- **告警准确率**: > 90%

---

## 🎯 总结

### **架构优势**
1. **简单直观**: 舍弃复杂DDD架构，采用直接的三层架构
2. **高度解耦**: 微服务独立部署，服务间松耦合
3. **可扩展性**: 支持水平扩展和弹性伸缩
4. **可观测性**: 完整的监控、日志、追踪体系
5. **高可用性**: 多副本部署，故障自愈

### **与旧架构对比**
| 方面 | 旧DDD架构 | 新微服务架构 |
|------|-----------|--------------|
| 复杂度 | 极高 (9层调用) | 简单 (3层) |
| 学习成本 | 2-3周 | 3-5天 |
| 维护成本 | 高 | 低 |
| 性能 | 一般 | 优秀 |
| 扩展性 | 困难 | 容易 |
| 部署复杂度 | 高 | 中等 |

### **预期收益**
- **开发效率**: 提升200%
- **系统性能**: 提升150%
- **维护成本**: 降低70%
- **故障恢复**: 提升300%

这个外部微服务架构完全舍弃了复杂的DDD设计，采用简单高效的方案，既保证了系统的功能完整性，又大大降低了复杂度和维护成本。
