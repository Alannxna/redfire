# ğŸš€ RedFireå¤–éƒ¨å¾®æœåŠ¡é…ç½®ç®¡ç†å™¨è®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ è®¾è®¡æ¦‚è¿°

**è®¾è®¡ç›®æ ‡**: èˆå¼ƒå¤æ‚çš„DDDæ¶æ„ï¼Œå»ºç«‹ç®€å•ã€é«˜æ•ˆçš„å¤–éƒ¨å¾®æœåŠ¡é…ç½®ç®¡ç†å™¨  
**æ ¸å¿ƒç†å¿µ**: é…ç½®å³æœåŠ¡ (Configuration as a Service)  
**æ¶æ„æ¨¡å¼**: ç®€å•åˆ†å±‚ + å¾®æœåŠ¡  
**å®æ–½ç­–ç•¥**: æ¸è¿›å¼æ›¿æ¢ï¼Œé›¶åœæœºè¿ç§»

---

## ğŸ¯ è®¾è®¡åŸåˆ™

### **Simple First (ç®€å•ä¼˜å…ˆ)**
- âŒ èˆå¼ƒè¿‡åº¦è®¾è®¡çš„DDDæ¶æ„
- âŒ ç§»é™¤å¤æ‚çš„CQRSæ¨¡å¼  
- âŒ ç®€åŒ–é¢†åŸŸæœåŠ¡å±‚æ¬¡
- âœ… é‡‡ç”¨ç›´æ¥çš„ä¸‰å±‚æ¶æ„: API â†’ Service â†’ Repository

### **Configuration as Service (é…ç½®å³æœåŠ¡)**
- âœ… é…ç½®ç®¡ç†ç‹¬ç«‹å¾®æœåŠ¡
- âœ… ç»Ÿä¸€çš„é…ç½®APIæ¥å£
- âœ… é›†ä¸­å¼é…ç½®å­˜å‚¨
- âœ… å®æ—¶é…ç½®æ¨é€

### **Zero Downtime Migration (é›¶åœæœºè¿ç§»)**
- âœ… å¹¶è¡Œè¿è¡Œæ–°æ—§ç³»ç»Ÿ
- âœ… ç°åº¦é…ç½®åˆ‡æ¢
- âœ… å®æ—¶é…ç½®åŒæ­¥
- âœ… å¿«é€Ÿå›æ»šæœºåˆ¶

---

## ğŸ—ï¸ æ–°æ¶æ„è®¾è®¡

### **æ•´ä½“æ¶æ„å›¾**

```mermaid
graph TB
    subgraph "RedFire Main System"
        A[Main App]
        B[Trading Service]
        C[Strategy Service]
        D[VnPy Engine]
    end
    
    subgraph "Config Management Microservice"
        E[Config API Gateway]
        F[Config Service]
        G[Config Repository]
        H[Config Cache]
    end
    
    subgraph "Config Storage"
        I[(PostgreSQL)]
        J[(Redis Cache)]
        K[File System]
        L[Environment]
    end
    
    A --> E
    B --> E
    C --> E
    D --> E
    E --> F
    F --> G
    F --> H
    G --> I
    H --> J
    F --> K
    F --> L
```

### **å¾®æœåŠ¡é…ç½®ç®¡ç†å™¨æ ¸å¿ƒæ¶æ„**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Config Management Service                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ“¡ API Layer                                              â”‚
â”‚  â”œâ”€â”€ /api/config/{service}/{key}          # è·å–é…ç½®      â”‚
â”‚  â”œâ”€â”€ /api/config/{service}                # è·å–æœåŠ¡é…ç½®  â”‚
â”‚  â”œâ”€â”€ /api/config/watch/{service}          # ç›‘å¬é…ç½®å˜æ›´  â”‚
â”‚  â”œâ”€â”€ /api/config/validate                 # éªŒè¯é…ç½®      â”‚
â”‚  â””â”€â”€ /api/config/reload                   # é‡è½½é…ç½®      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ”§ Service Layer                                          â”‚
â”‚  â”œâ”€â”€ ConfigService                        # é…ç½®ç®¡ç†æœåŠ¡  â”‚
â”‚  â”œâ”€â”€ ValidationService                    # é…ç½®éªŒè¯æœåŠ¡  â”‚
â”‚  â”œâ”€â”€ NotificationService                  # é…ç½®æ¨é€æœåŠ¡  â”‚
â”‚  â””â”€â”€ CacheService                         # é…ç½®ç¼“å­˜æœåŠ¡  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ’¾ Repository Layer                                       â”‚
â”‚  â”œâ”€â”€ DatabaseConfigRepository             # æ•°æ®åº“é…ç½®    â”‚
â”‚  â”œâ”€â”€ FileConfigRepository                 # æ–‡ä»¶é…ç½®      â”‚
â”‚  â”œâ”€â”€ EnvironmentConfigRepository          # ç¯å¢ƒå˜é‡     â”‚
â”‚  â””â”€â”€ CacheConfigRepository                # ç¼“å­˜é…ç½®      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ“Š Storage Layer                                          â”‚
â”‚  â”œâ”€â”€ PostgreSQL (ä¸»é…ç½®å­˜å‚¨)                              â”‚
â”‚  â”œâ”€â”€ Redis (é…ç½®ç¼“å­˜)                                     â”‚
â”‚  â”œâ”€â”€ File System (é…ç½®æ–‡ä»¶)                               â”‚
â”‚  â””â”€â”€ Environment Variables (ç¯å¢ƒå˜é‡)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“± é…ç½®ç®¡ç†å™¨æ ¸å¿ƒå®ç°

### **1. é…ç½®æ•°æ®æ¨¡å‹**

```python
# config_service/models.py
from pydantic import BaseModel, Field
from typing import Dict, Any, Optional, List
from datetime import datetime
from enum import Enum

class ConfigType(str, Enum):
    """é…ç½®ç±»å‹"""
    DATABASE = "database"
    REDIS = "redis"
    VNPY = "vnpy"
    API = "api"
    SECURITY = "security"
    MONITORING = "monitoring"

class ConfigScope(str, Enum):
    """é…ç½®ä½œç”¨åŸŸ"""
    GLOBAL = "global"
    SERVICE = "service"
    USER = "user"
    ENVIRONMENT = "environment"

class ConfigEntry(BaseModel):
    """é…ç½®æ¡ç›®"""
    id: str = Field(..., description="é…ç½®ID")
    service_name: str = Field(..., description="æœåŠ¡åç§°")
    config_key: str = Field(..., description="é…ç½®é”®")
    config_value: Any = Field(..., description="é…ç½®å€¼")
    config_type: ConfigType = Field(..., description="é…ç½®ç±»å‹")
    scope: ConfigScope = Field(ConfigScope.SERVICE, description="é…ç½®ä½œç”¨åŸŸ")
    environment: str = Field("production", description="ç¯å¢ƒ")
    version: int = Field(1, description="é…ç½®ç‰ˆæœ¬")
    description: Optional[str] = Field(None, description="é…ç½®æè¿°")
    is_encrypted: bool = Field(False, description="æ˜¯å¦åŠ å¯†")
    is_active: bool = Field(True, description="æ˜¯å¦æ¿€æ´»")
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: Optional[datetime] = None
    created_by: str = Field("system", description="åˆ›å»ºè€…")
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }

class ServiceConfig(BaseModel):
    """æœåŠ¡é…ç½®"""
    service_name: str = Field(..., description="æœåŠ¡åç§°")
    environment: str = Field("production", description="ç¯å¢ƒ")
    configs: Dict[str, Any] = Field(default_factory=dict, description="é…ç½®å­—å…¸")
    version: int = Field(1, description="é…ç½®ç‰ˆæœ¬")
    last_updated: datetime = Field(default_factory=datetime.now)

class ConfigChangeEvent(BaseModel):
    """é…ç½®å˜æ›´äº‹ä»¶"""
    event_id: str = Field(..., description="äº‹ä»¶ID")
    service_name: str = Field(..., description="æœåŠ¡åç§°")
    config_key: str = Field(..., description="é…ç½®é”®")
    old_value: Any = Field(None, description="æ—§å€¼")
    new_value: Any = Field(..., description="æ–°å€¼")
    change_type: str = Field(..., description="å˜æ›´ç±»å‹: create/update/delete")
    environment: str = Field(..., description="ç¯å¢ƒ")
    timestamp: datetime = Field(default_factory=datetime.now)
    changed_by: str = Field("system", description="å˜æ›´è€…")
```

### **2. é…ç½®æœåŠ¡æ ¸å¿ƒå®ç°**

```python
# config_service/services/config_service.py
from typing import Dict, Any, Optional, List
import asyncio
import json
import logging
from datetime import datetime

from .models import ConfigEntry, ServiceConfig, ConfigChangeEvent
from .repositories import ConfigRepository
from .cache import ConfigCache
from .validators import ConfigValidator
from .notifier import ConfigNotifier

logger = logging.getLogger(__name__)

class ConfigService:
    """é…ç½®ç®¡ç†æœåŠ¡"""
    
    def __init__(
        self,
        repository: ConfigRepository,
        cache: ConfigCache,
        validator: ConfigValidator,
        notifier: ConfigNotifier
    ):
        self.repository = repository
        self.cache = cache
        self.validator = validator
        self.notifier = notifier
        
    async def get_service_config(
        self, 
        service_name: str, 
        environment: str = "production"
    ) -> Optional[ServiceConfig]:
        """è·å–æœåŠ¡é…ç½®"""
        cache_key = f"service_config:{service_name}:{environment}"
        
        # 1. å°è¯•ä»ç¼“å­˜è·å–
        cached_config = await self.cache.get(cache_key)
        if cached_config:
            return ServiceConfig.parse_obj(cached_config)
        
        # 2. ä»æ•°æ®åº“è·å–
        config_entries = await self.repository.get_service_configs(
            service_name, environment
        )
        
        if not config_entries:
            return None
        
        # 3. æ„å»ºæœåŠ¡é…ç½®
        configs = {}
        for entry in config_entries:
            if entry.is_active:
                configs[entry.config_key] = entry.config_value
        
        service_config = ServiceConfig(
            service_name=service_name,
            environment=environment,
            configs=configs,
            version=max(entry.version for entry in config_entries),
            last_updated=max(entry.updated_at or entry.created_at for entry in config_entries)
        )
        
        # 4. ç¼“å­˜é…ç½®
        await self.cache.set(cache_key, service_config.dict(), ttl=300)
        
        return service_config
    
    async def get_config_value(
        self,
        service_name: str,
        config_key: str,
        environment: str = "production",
        default: Any = None
    ) -> Any:
        """è·å–é…ç½®å€¼"""
        service_config = await self.get_service_config(service_name, environment)
        if not service_config:
            return default
        
        return service_config.configs.get(config_key, default)
    
    async def set_config(
        self,
        service_name: str,
        config_key: str,
        config_value: Any,
        config_type: str = "api",
        environment: str = "production",
        changed_by: str = "system"
    ) -> ConfigEntry:
        """è®¾ç½®é…ç½®"""
        
        # 1. éªŒè¯é…ç½®
        await self.validator.validate_config(
            service_name, config_key, config_value, config_type
        )
        
        # 2. è·å–ç°æœ‰é…ç½®
        existing_config = await self.repository.get_config(
            service_name, config_key, environment
        )
        
        # 3. åˆ›å»ºæˆ–æ›´æ–°é…ç½®
        if existing_config:
            # æ›´æ–°é…ç½®
            old_value = existing_config.config_value
            existing_config.config_value = config_value
            existing_config.version += 1
            existing_config.updated_at = datetime.now()
            
            config_entry = await self.repository.update_config(existing_config)
            change_type = "update"
        else:
            # åˆ›å»ºæ–°é…ç½®
            config_entry = ConfigEntry(
                id=f"{service_name}:{config_key}:{environment}",
                service_name=service_name,
                config_key=config_key,
                config_value=config_value,
                config_type=config_type,
                environment=environment,
                created_by=changed_by
            )
            config_entry = await self.repository.create_config(config_entry)
            old_value = None
            change_type = "create"
        
        # 4. æ¸…é™¤ç¼“å­˜
        await self._invalidate_cache(service_name, environment)
        
        # 5. å‘é€å˜æ›´é€šçŸ¥
        change_event = ConfigChangeEvent(
            event_id=f"{config_entry.id}:{datetime.now().timestamp()}",
            service_name=service_name,
            config_key=config_key,
            old_value=old_value,
            new_value=config_value,
            change_type=change_type,
            environment=environment,
            changed_by=changed_by
        )
        
        await self.notifier.notify_config_change(change_event)
        
        return config_entry
    
    async def delete_config(
        self,
        service_name: str,
        config_key: str,
        environment: str = "production",
        changed_by: str = "system"
    ) -> bool:
        """åˆ é™¤é…ç½®"""
        
        # 1. è·å–ç°æœ‰é…ç½®
        existing_config = await self.repository.get_config(
            service_name, config_key, environment
        )
        
        if not existing_config:
            return False
        
        # 2. åˆ é™¤é…ç½®
        success = await self.repository.delete_config(
            service_name, config_key, environment
        )
        
        if success:
            # 3. æ¸…é™¤ç¼“å­˜
            await self._invalidate_cache(service_name, environment)
            
            # 4. å‘é€å˜æ›´é€šçŸ¥
            change_event = ConfigChangeEvent(
                event_id=f"{existing_config.id}:delete:{datetime.now().timestamp()}",
                service_name=service_name,
                config_key=config_key,
                old_value=existing_config.config_value,
                new_value=None,
                change_type="delete",
                environment=environment,
                changed_by=changed_by
            )
            
            await self.notifier.notify_config_change(change_event)
        
        return success
    
    async def reload_service_config(
        self, 
        service_name: str, 
        environment: str = "production"
    ) -> bool:
        """é‡è½½æœåŠ¡é…ç½®"""
        try:
            # 1. æ¸…é™¤ç¼“å­˜
            await self._invalidate_cache(service_name, environment)
            
            # 2. é¢„çƒ­ç¼“å­˜
            await self.get_service_config(service_name, environment)
            
            # 3. é€šçŸ¥æœåŠ¡é‡è½½
            await self.notifier.notify_service_reload(service_name, environment)
            
            logger.info(f"Reloaded config for service: {service_name}, env: {environment}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to reload config for {service_name}: {e}")
            return False
    
    async def _invalidate_cache(self, service_name: str, environment: str):
        """æ¸…é™¤ç¼“å­˜"""
        cache_key = f"service_config:{service_name}:{environment}"
        await self.cache.delete(cache_key)
        
        # æ¸…é™¤ç›¸å…³çš„é…ç½®ç¼“å­˜
        pattern = f"config:{service_name}:*:{environment}"
        await self.cache.delete_pattern(pattern)
```

### **3. é…ç½®ä»“å‚¨å®ç°**

```python
# config_service/repositories/config_repository.py
from typing import List, Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete
from sqlalchemy.orm import selectinload

from ..models import ConfigEntry
from ..database import get_async_session

class ConfigRepository:
    """é…ç½®ä»“å‚¨"""
    
    def __init__(self, db_session: AsyncSession):
        self.db_session = db_session
    
    async def get_config(
        self,
        service_name: str,
        config_key: str,
        environment: str
    ) -> Optional[ConfigEntry]:
        """è·å–å•ä¸ªé…ç½®"""
        stmt = select(ConfigEntry).where(
            ConfigEntry.service_name == service_name,
            ConfigEntry.config_key == config_key,
            ConfigEntry.environment == environment,
            ConfigEntry.is_active == True
        )
        
        result = await self.db_session.execute(stmt)
        return result.scalar_one_or_none()
    
    async def get_service_configs(
        self,
        service_name: str,
        environment: str
    ) -> List[ConfigEntry]:
        """è·å–æœåŠ¡æ‰€æœ‰é…ç½®"""
        stmt = select(ConfigEntry).where(
            ConfigEntry.service_name == service_name,
            ConfigEntry.environment == environment,
            ConfigEntry.is_active == True
        ).order_by(ConfigEntry.config_key)
        
        result = await self.db_session.execute(stmt)
        return result.scalars().all()
    
    async def create_config(self, config: ConfigEntry) -> ConfigEntry:
        """åˆ›å»ºé…ç½®"""
        self.db_session.add(config)
        await self.db_session.commit()
        await self.db_session.refresh(config)
        return config
    
    async def update_config(self, config: ConfigEntry) -> ConfigEntry:
        """æ›´æ–°é…ç½®"""
        await self.db_session.commit()
        await self.db_session.refresh(config)
        return config
    
    async def delete_config(
        self,
        service_name: str,
        config_key: str,
        environment: str
    ) -> bool:
        """åˆ é™¤é…ç½® (è½¯åˆ é™¤)"""
        stmt = update(ConfigEntry).where(
            ConfigEntry.service_name == service_name,
            ConfigEntry.config_key == config_key,
            ConfigEntry.environment == environment
        ).values(is_active=False)
        
        result = await self.db_session.execute(stmt)
        await self.db_session.commit()
        return result.rowcount > 0
    
    async def list_services(self) -> List[str]:
        """åˆ—å‡ºæ‰€æœ‰æœåŠ¡"""
        stmt = select(ConfigEntry.service_name).distinct()
        result = await self.db_session.execute(stmt)
        return [row[0] for row in result.fetchall()]
```

### **4. é…ç½®ç¼“å­˜å®ç°**

```python
# config_service/cache/config_cache.py
import json
import redis.asyncio as redis
from typing import Any, Optional, Pattern
import logging

logger = logging.getLogger(__name__)

class ConfigCache:
    """é…ç½®ç¼“å­˜"""
    
    def __init__(self, redis_url: str):
        self.redis = redis.from_url(redis_url)
    
    async def get(self, key: str) -> Optional[Any]:
        """è·å–ç¼“å­˜"""
        try:
            value = await self.redis.get(key)
            if value:
                return json.loads(value)
            return None
        except Exception as e:
            logger.error(f"Cache get error for key {key}: {e}")
            return None
    
    async def set(self, key: str, value: Any, ttl: int = 3600):
        """è®¾ç½®ç¼“å­˜"""
        try:
            await self.redis.setex(key, ttl, json.dumps(value, default=str))
        except Exception as e:
            logger.error(f"Cache set error for key {key}: {e}")
    
    async def delete(self, key: str):
        """åˆ é™¤ç¼“å­˜"""
        try:
            await self.redis.delete(key)
        except Exception as e:
            logger.error(f"Cache delete error for key {key}: {e}")
    
    async def delete_pattern(self, pattern: str):
        """æŒ‰æ¨¡å¼åˆ é™¤ç¼“å­˜"""
        try:
            keys = await self.redis.keys(pattern)
            if keys:
                await self.redis.delete(*keys)
        except Exception as e:
            logger.error(f"Cache delete pattern error for {pattern}: {e}")
    
    async def exists(self, key: str) -> bool:
        """æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨"""
        try:
            return await self.redis.exists(key) > 0
        except Exception as e:
            logger.error(f"Cache exists error for key {key}: {e}")
            return False
```

### **5. é…ç½®é€šçŸ¥å™¨å®ç°**

```python
# config_service/notifiers/config_notifier.py
import asyncio
import json
import logging
from typing import List, Dict, Any
import redis.asyncio as redis
from fastapi import WebSocket

from ..models import ConfigChangeEvent

logger = logging.getLogger(__name__)

class ConfigNotifier:
    """é…ç½®å˜æ›´é€šçŸ¥å™¨"""
    
    def __init__(self, redis_url: str):
        self.redis = redis.from_url(redis_url)
        self.websocket_connections: Dict[str, List[WebSocket]] = {}
    
    async def notify_config_change(self, event: ConfigChangeEvent):
        """é€šçŸ¥é…ç½®å˜æ›´"""
        try:
            # 1. Rediså‘å¸ƒé€šçŸ¥
            channel = f"config_change:{event.service_name}:{event.environment}"
            await self.redis.publish(channel, event.json())
            
            # 2. WebSocketæ¨é€é€šçŸ¥
            await self._notify_websocket_clients(event)
            
            logger.info(f"Config change notification sent: {event.service_name}.{event.config_key}")
            
        except Exception as e:
            logger.error(f"Failed to notify config change: {e}")
    
    async def notify_service_reload(self, service_name: str, environment: str):
        """é€šçŸ¥æœåŠ¡é‡è½½"""
        try:
            channel = f"service_reload:{service_name}:{environment}"
            message = {
                "service_name": service_name,
                "environment": environment,
                "action": "reload",
                "timestamp": asyncio.get_event_loop().time()
            }
            
            await self.redis.publish(channel, json.dumps(message))
            logger.info(f"Service reload notification sent: {service_name}")
            
        except Exception as e:
            logger.error(f"Failed to notify service reload: {e}")
    
    async def subscribe_to_changes(
        self, 
        service_name: str, 
        environment: str,
        callback
    ):
        """è®¢é˜…é…ç½®å˜æ›´"""
        try:
            pubsub = self.redis.pubsub()
            channel = f"config_change:{service_name}:{environment}"
            await pubsub.subscribe(channel)
            
            async for message in pubsub.listen():
                if message['type'] == 'message':
                    event_data = json.loads(message['data'])
                    event = ConfigChangeEvent.parse_obj(event_data)
                    await callback(event)
                    
        except Exception as e:
            logger.error(f"Failed to subscribe to changes: {e}")
    
    async def add_websocket_connection(self, service_name: str, websocket: WebSocket):
        """æ·»åŠ WebSocketè¿æ¥"""
        if service_name not in self.websocket_connections:
            self.websocket_connections[service_name] = []
        
        self.websocket_connections[service_name].append(websocket)
    
    async def remove_websocket_connection(self, service_name: str, websocket: WebSocket):
        """ç§»é™¤WebSocketè¿æ¥"""
        if service_name in self.websocket_connections:
            try:
                self.websocket_connections[service_name].remove(websocket)
            except ValueError:
                pass
    
    async def _notify_websocket_clients(self, event: ConfigChangeEvent):
        """é€šçŸ¥WebSocketå®¢æˆ·ç«¯"""
        service_name = event.service_name
        
        if service_name not in self.websocket_connections:
            return
        
        # è·å–è¿æ¥åˆ—è¡¨çš„å‰¯æœ¬ï¼Œé¿å…å¹¶å‘ä¿®æ”¹
        connections = self.websocket_connections[service_name][:]
        
        for websocket in connections:
            try:
                await websocket.send_text(event.json())
            except Exception as e:
                logger.error(f"Failed to send websocket message: {e}")
                # ç§»é™¤å¤±æ•ˆè¿æ¥
                await self.remove_websocket_connection(service_name, websocket)
```

---

## ğŸ”Œ é…ç½®ç®¡ç†å™¨APIæ¥å£

### **REST API è®¾è®¡**

```python
# config_service/api/config_router.py
from fastapi import APIRouter, Depends, HTTPException, WebSocket, WebSocketDisconnect
from typing import Any, Dict, Optional
import logging

from ..services import ConfigService
from ..models import ConfigEntry, ServiceConfig
from ..dependencies import get_config_service, get_notifier

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/api/config", tags=["é…ç½®ç®¡ç†"])

@router.get("/health")
async def health_check():
    """å¥åº·æ£€æŸ¥"""
    return {"status": "healthy", "service": "config-management"}

@router.get("/services/{service_name}", response_model=ServiceConfig)
async def get_service_config(
    service_name: str,
    environment: str = "production",
    config_service: ConfigService = Depends(get_config_service)
):
    """è·å–æœåŠ¡å®Œæ•´é…ç½®"""
    config = await config_service.get_service_config(service_name, environment)
    if not config:
        raise HTTPException(status_code=404, detail=f"Service config not found: {service_name}")
    
    return config

@router.get("/services/{service_name}/{config_key}")
async def get_config_value(
    service_name: str,
    config_key: str,
    environment: str = "production",
    default: Optional[str] = None,
    config_service: ConfigService = Depends(get_config_service)
):
    """è·å–ç‰¹å®šé…ç½®å€¼"""
    value = await config_service.get_config_value(
        service_name, config_key, environment, default
    )
    
    return {"service": service_name, "key": config_key, "value": value}

@router.put("/services/{service_name}/{config_key}")
async def set_config_value(
    service_name: str,
    config_key: str,
    config_data: Dict[str, Any],
    environment: str = "production",
    config_service: ConfigService = Depends(get_config_service)
):
    """è®¾ç½®é…ç½®å€¼"""
    config_value = config_data.get("value")
    config_type = config_data.get("type", "api")
    changed_by = config_data.get("changed_by", "api")
    
    if config_value is None:
        raise HTTPException(status_code=400, detail="Config value is required")
    
    try:
        config_entry = await config_service.set_config(
            service_name, config_key, config_value, config_type, environment, changed_by
        )
        return {"status": "success", "config": config_entry}
    
    except Exception as e:
        logger.error(f"Failed to set config: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.delete("/services/{service_name}/{config_key}")
async def delete_config_value(
    service_name: str,
    config_key: str,
    environment: str = "production",
    changed_by: str = "api",
    config_service: ConfigService = Depends(get_config_service)
):
    """åˆ é™¤é…ç½®å€¼"""
    success = await config_service.delete_config(
        service_name, config_key, environment, changed_by
    )
    
    if not success:
        raise HTTPException(status_code=404, detail="Config not found")
    
    return {"status": "success", "message": "Config deleted"}

@router.post("/services/{service_name}/reload")
async def reload_service_config(
    service_name: str,
    environment: str = "production",
    config_service: ConfigService = Depends(get_config_service)
):
    """é‡è½½æœåŠ¡é…ç½®"""
    success = await config_service.reload_service_config(service_name, environment)
    
    if not success:
        raise HTTPException(status_code=500, detail="Failed to reload config")
    
    return {"status": "success", "message": f"Config reloaded for {service_name}"}

@router.websocket("/services/{service_name}/watch")
async def watch_config_changes(
    websocket: WebSocket,
    service_name: str,
    environment: str = "production",
    notifier = Depends(get_notifier)
):
    """ç›‘å¬é…ç½®å˜æ›´ - WebSocket"""
    await websocket.accept()
    await notifier.add_websocket_connection(service_name, websocket)
    
    try:
        while True:
            # ä¿æŒè¿æ¥æ´»è·ƒ
            await websocket.receive_text()
    
    except WebSocketDisconnect:
        await notifier.remove_websocket_connection(service_name, websocket)
    
    except Exception as e:
        logger.error(f"WebSocket error: {e}")
        await notifier.remove_websocket_connection(service_name, websocket)
```

---

## ğŸš€ å®¢æˆ·ç«¯SDKè®¾è®¡

### **Python SDK**

```python
# redfire_config_client/client.py
import asyncio
import aiohttp
import json
import logging
from typing import Any, Optional, Dict, Callable
import websockets

logger = logging.getLogger(__name__)

class RedFireConfigClient:
    """RedFireé…ç½®ç®¡ç†å®¢æˆ·ç«¯"""
    
    def __init__(
        self,
        config_service_url: str,
        service_name: str,
        environment: str = "production",
        cache_ttl: int = 300
    ):
        self.config_service_url = config_service_url.rstrip('/')
        self.service_name = service_name
        self.environment = environment
        self.cache_ttl = cache_ttl
        
        self._config_cache: Dict[str, Any] = {}
        self._cache_timestamps: Dict[str, float] = {}
        self._change_callbacks: List[Callable] = []
        
    async def get_config(self, key: str, default: Any = None) -> Any:
        """è·å–é…ç½®å€¼"""
        # æ£€æŸ¥ç¼“å­˜
        if self._is_cached(key):
            return self._config_cache.get(key, default)
        
        # ä»è¿œç¨‹è·å–
        try:
            url = f"{self.config_service_url}/api/config/services/{self.service_name}/{key}"
            params = {"environment": self.environment, "default": default}
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        value = data.get("value", default)
                        
                        # æ›´æ–°ç¼“å­˜
                        self._config_cache[key] = value
                        self._cache_timestamps[key] = asyncio.get_event_loop().time()
                        
                        return value
                    elif response.status == 404:
                        return default
                    else:
                        logger.error(f"Failed to get config {key}: {response.status}")
                        return default
        
        except Exception as e:
            logger.error(f"Error getting config {key}: {e}")
            return default
    
    async def get_all_configs(self) -> Dict[str, Any]:
        """è·å–æ‰€æœ‰é…ç½®"""
        try:
            url = f"{self.config_service_url}/api/config/services/{self.service_name}"
            params = {"environment": self.environment}
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        configs = data.get("configs", {})
                        
                        # æ›´æ–°ç¼“å­˜
                        current_time = asyncio.get_event_loop().time()
                        for key, value in configs.items():
                            self._config_cache[key] = value
                            self._cache_timestamps[key] = current_time
                        
                        return configs
                    else:
                        logger.error(f"Failed to get all configs: {response.status}")
                        return {}
        
        except Exception as e:
            logger.error(f"Error getting all configs: {e}")
            return {}
    
    async def set_config(self, key: str, value: Any, changed_by: str = "client") -> bool:
        """è®¾ç½®é…ç½®å€¼"""
        try:
            url = f"{self.config_service_url}/api/config/services/{self.service_name}/{key}"
            params = {"environment": self.environment}
            data = {"value": value, "changed_by": changed_by}
            
            async with aiohttp.ClientSession() as session:
                async with session.put(url, params=params, json=data) as response:
                    if response.status == 200:
                        # æ›´æ–°ç¼“å­˜
                        self._config_cache[key] = value
                        self._cache_timestamps[key] = asyncio.get_event_loop().time()
                        return True
                    else:
                        logger.error(f"Failed to set config {key}: {response.status}")
                        return False
        
        except Exception as e:
            logger.error(f"Error setting config {key}: {e}")
            return False
    
    async def watch_changes(self, callback: Callable[[str, Any, Any], None]):
        """ç›‘å¬é…ç½®å˜æ›´"""
        self._change_callbacks.append(callback)
        
        # å¯åŠ¨WebSocketè¿æ¥
        asyncio.create_task(self._start_websocket_listener())
    
    async def reload_config(self) -> bool:
        """é‡è½½é…ç½®"""
        try:
            url = f"{self.config_service_url}/api/config/services/{self.service_name}/reload"
            params = {"environment": self.environment}
            
            async with aiohttp.ClientSession() as session:
                async with session.post(url, params=params) as response:
                    if response.status == 200:
                        # æ¸…é™¤ç¼“å­˜
                        self._config_cache.clear()
                        self._cache_timestamps.clear()
                        return True
                    else:
                        logger.error(f"Failed to reload config: {response.status}")
                        return False
        
        except Exception as e:
            logger.error(f"Error reloading config: {e}")
            return False
    
    def _is_cached(self, key: str) -> bool:
        """æ£€æŸ¥é…ç½®æ˜¯å¦åœ¨ç¼“å­˜ä¸­ä¸”æœªè¿‡æœŸ"""
        if key not in self._config_cache:
            return False
        
        cache_time = self._cache_timestamps.get(key, 0)
        current_time = asyncio.get_event_loop().time()
        
        return (current_time - cache_time) < self.cache_ttl
    
    async def _start_websocket_listener(self):
        """å¯åŠ¨WebSocketç›‘å¬å™¨"""
        ws_url = self.config_service_url.replace("http", "ws")
        ws_url += f"/api/config/services/{self.service_name}/watch"
        ws_url += f"?environment={self.environment}"
        
        try:
            async with websockets.connect(ws_url) as websocket:
                async for message in websocket:
                    try:
                        event_data = json.loads(message)
                        config_key = event_data.get("config_key")
                        old_value = event_data.get("old_value")
                        new_value = event_data.get("new_value")
                        
                        # æ›´æ–°ç¼“å­˜
                        if new_value is not None:
                            self._config_cache[config_key] = new_value
                            self._cache_timestamps[config_key] = asyncio.get_event_loop().time()
                        
                        # è°ƒç”¨å›è°ƒå‡½æ•°
                        for callback in self._change_callbacks:
                            try:
                                await callback(config_key, old_value, new_value)
                            except Exception as e:
                                logger.error(f"Error in change callback: {e}")
                    
                    except Exception as e:
                        logger.error(f"Error processing WebSocket message: {e}")
        
        except Exception as e:
            logger.error(f"WebSocket connection error: {e}")

# ä¾¿æ·çš„è£…é¥°å™¨å‡½æ•°
def config_value(key: str, default: Any = None, client: RedFireConfigClient = None):
    """é…ç½®å€¼è£…é¥°å™¨"""
    def decorator(func):
        async def wrapper(*args, **kwargs):
            if client:
                value = await client.get_config(key, default)
                kwargs[key] = value
            return await func(*args, **kwargs)
        return wrapper
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
# @config_value("database_url", client=config_client)
# async def connect_database(database_url: str):
#     return f"Connecting to {database_url}"
```

---

## âš¡ è¿ç§»ç­–ç•¥ä¸å®æ–½

### **Phase 1: å¹¶è¡Œéƒ¨ç½² (Week 1-2)**

```python
# migration/parallel_deployment.py
class ConfigMigrationManager:
    """é…ç½®è¿ç§»ç®¡ç†å™¨"""
    
    def __init__(self, old_config_manager, new_config_service):
        self.old_config = old_config_manager
        self.new_config = new_config_service
        self.migration_mode = "parallel"  # parallel, new_only, old_only
    
    async def get_config(self, service_name: str, key: str, default: Any = None):
        """è·å–é…ç½® - å…¼å®¹æ¨¡å¼"""
        if self.migration_mode == "old_only":
            return await self.old_config.get_config(service_name, key, default)
        
        elif self.migration_mode == "new_only":
            return await self.new_config.get_config_value(service_name, key, default)
        
        else:  # parallel mode
            # ä¼˜å…ˆä»æ–°ç³»ç»Ÿè·å–
            try:
                new_value = await self.new_config.get_config_value(
                    service_name, key, default
                )
                if new_value is not None:
                    return new_value
            except Exception as e:
                logger.warning(f"New config service failed: {e}")
            
            # é™çº§åˆ°æ—§ç³»ç»Ÿ
            try:
                old_value = await self.old_config.get_config(service_name, key, default)
                return old_value
            except Exception as e:
                logger.error(f"Both config systems failed: {e}")
                return default
    
    async def sync_configs(self):
        """åŒæ­¥é…ç½®æ•°æ®"""
        # ä»æ—§ç³»ç»Ÿè¯»å–æ‰€æœ‰é…ç½®
        old_configs = await self.old_config.get_all_configs()
        
        # åŒæ­¥åˆ°æ–°ç³»ç»Ÿ
        for service_name, service_configs in old_configs.items():
            for key, value in service_configs.items():
                await self.new_config.set_config(
                    service_name, key, value, "migration", "production", "migration_bot"
                )
        
        logger.info(f"Migrated {len(old_configs)} service configurations")
```

### **Phase 2: ç°åº¦åˆ‡æ¢ (Week 3-4)**

```python
# migration/gradual_migration.py
class GradualMigrationController:
    """æ¸è¿›å¼è¿ç§»æ§åˆ¶å™¨"""
    
    def __init__(self):
        self.migration_percentage = 0  # 0-100
        self.service_whitelist = set()  # å·²è¿ç§»çš„æœåŠ¡
        
    def should_use_new_config(self, service_name: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä½¿ç”¨æ–°é…ç½®ç³»ç»Ÿ"""
        # ç™½åå•æœåŠ¡å¼ºåˆ¶ä½¿ç”¨æ–°ç³»ç»Ÿ
        if service_name in self.service_whitelist:
            return True
        
        # æŒ‰ç™¾åˆ†æ¯”ç°åº¦
        import hashlib
        hash_value = int(hashlib.md5(service_name.encode()).hexdigest(), 16)
        return (hash_value % 100) < self.migration_percentage
    
    async def migrate_service(self, service_name: str):
        """è¿ç§»ç‰¹å®šæœåŠ¡"""
        self.service_whitelist.add(service_name)
        logger.info(f"Service {service_name} migrated to new config system")
    
    async def rollback_service(self, service_name: str):
        """å›æ»šç‰¹å®šæœåŠ¡"""
        self.service_whitelist.discard(service_name)
        logger.info(f"Service {service_name} rolled back to old config system")
```

---

## ğŸ“Š ç›‘æ§å’Œå¯è§‚æµ‹æ€§

### **é…ç½®ç®¡ç†ç›‘æ§æŒ‡æ ‡**

```python
# monitoring/config_metrics.py
from prometheus_client import Counter, Histogram, Gauge, Info

# é…ç½®è®¿é—®æŒ‡æ ‡
config_requests_total = Counter(
    'config_requests_total',
    'Total config requests',
    ['service_name', 'config_key', 'status']
)

config_request_duration = Histogram(
    'config_request_duration_seconds',
    'Config request duration',
    ['service_name', 'operation']
)

# é…ç½®ç¼“å­˜æŒ‡æ ‡
config_cache_hits = Counter(
    'config_cache_hits_total',
    'Total config cache hits',
    ['service_name']
)

config_cache_misses = Counter(
    'config_cache_misses_total', 
    'Total config cache misses',
    ['service_name']
)

# é…ç½®å˜æ›´æŒ‡æ ‡
config_changes_total = Counter(
    'config_changes_total',
    'Total config changes',
    ['service_name', 'change_type']
)

# æ´»è·ƒé…ç½®æ•°é‡
active_configs_count = Gauge(
    'active_configs_count',
    'Number of active configs',
    ['service_name', 'environment']
)

# ç³»ç»Ÿä¿¡æ¯
config_service_info = Info(
    'config_service_info',
    'Config service information'
)

class ConfigMetrics:
    """é…ç½®ç®¡ç†æŒ‡æ ‡æ”¶é›†å™¨"""
    
    @staticmethod
    def record_request(service_name: str, config_key: str, status: str, duration: float):
        """è®°å½•é…ç½®è¯·æ±‚"""
        config_requests_total.labels(
            service_name=service_name,
            config_key=config_key, 
            status=status
        ).inc()
        
        config_request_duration.labels(
            service_name=service_name,
            operation="get_config"
        ).observe(duration)
    
    @staticmethod
    def record_cache_hit(service_name: str):
        """è®°å½•ç¼“å­˜å‘½ä¸­"""
        config_cache_hits.labels(service_name=service_name).inc()
    
    @staticmethod
    def record_cache_miss(service_name: str):
        """è®°å½•ç¼“å­˜æœªå‘½ä¸­"""
        config_cache_misses.labels(service_name=service_name).inc()
    
    @staticmethod
    def record_config_change(service_name: str, change_type: str):
        """è®°å½•é…ç½®å˜æ›´"""
        config_changes_total.labels(
            service_name=service_name,
            change_type=change_type
        ).inc()
```

### **å¥åº·æ£€æŸ¥å’Œå‘Šè­¦**

```python
# monitoring/health_check.py
from typing import Dict, Any
import asyncio
import aiohttp

class ConfigServiceHealthCheck:
    """é…ç½®æœåŠ¡å¥åº·æ£€æŸ¥"""
    
    def __init__(self, config_service, cache_service, repository):
        self.config_service = config_service
        self.cache_service = cache_service
        self.repository = repository
    
    async def check_health(self) -> Dict[str, Any]:
        """å¥åº·æ£€æŸ¥"""
        health_status = {
            "status": "healthy",
            "timestamp": asyncio.get_event_loop().time(),
            "checks": {}
        }
        
        # æ£€æŸ¥æ•°æ®åº“è¿æ¥
        try:
            await self.repository.list_services()
            health_status["checks"]["database"] = {"status": "healthy"}
        except Exception as e:
            health_status["checks"]["database"] = {"status": "unhealthy", "error": str(e)}
            health_status["status"] = "unhealthy"
        
        # æ£€æŸ¥ç¼“å­˜è¿æ¥
        try:
            await self.cache_service.redis.ping()
            health_status["checks"]["cache"] = {"status": "healthy"}
        except Exception as e:
            health_status["checks"]["cache"] = {"status": "unhealthy", "error": str(e)}
            health_status["status"] = "unhealthy"
        
        # æ£€æŸ¥é…ç½®æœåŠ¡
        try:
            test_config = await self.config_service.get_config_value(
                "health_check", "test", "default"
            )
            health_status["checks"]["config_service"] = {"status": "healthy"}
        except Exception as e:
            health_status["checks"]["config_service"] = {"status": "unhealthy", "error": str(e)}
            health_status["status"] = "unhealthy"
        
        return health_status
```

---

## ğŸ”§ éƒ¨ç½²é…ç½®

### **Dockerå®¹å™¨åŒ–**

```dockerfile
# Dockerfile.config-service
FROM python:3.11-slim

WORKDIR /app

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY config_service/ ./config_service/
COPY main.py .

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/api/config/health || exit 1

# æš´éœ²ç«¯å£
EXPOSE 8080

# å¯åŠ¨å‘½ä»¤
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8080"]
```

### **Kuberneteséƒ¨ç½²**

```yaml
# k8s/config-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: config-service
  namespace: redfire
spec:
  replicas: 3
  selector:
    matchLabels:
      app: config-service
  template:
    metadata:
      labels:
        app: config-service
    spec:
      containers:
      - name: config-service
        image: redfire/config-service:latest
        ports:
        - containerPort: 8080
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: config-service-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: config-service-secrets
              key: redis-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /api/config/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/config/health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: config-service
  namespace: redfire
spec:
  selector:
    app: config-service
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: ClusterIP

---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: config-service-ingress
  namespace: redfire
spec:
  rules:
  - host: config.redfire.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: config-service
            port:
              number: 80
```

---

## ğŸš€ å®æ–½æ—¶é—´çº¿

### **Week 1-2: åŸºç¡€å®æ–½**
- [x] å®Œæˆé…ç½®æœåŠ¡æ ¸å¿ƒè®¾è®¡
- [ ] å®ç°é…ç½®æ•°æ®æ¨¡å‹å’ŒAPI
- [ ] å»ºç«‹æ•°æ®åº“å’Œç¼“å­˜
- [ ] å¼€å‘å®¢æˆ·ç«¯SDK

### **Week 3-4: é›†æˆæµ‹è¯•**
- [ ] éƒ¨ç½²é…ç½®æœåŠ¡åˆ°æµ‹è¯•ç¯å¢ƒ
- [ ] å®ç°å¹¶è¡Œæ¨¡å¼è¿ç§»
- [ ] å®¢æˆ·ç«¯é›†æˆæµ‹è¯•
- [ ] æ€§èƒ½å’Œç¨³å®šæ€§æµ‹è¯•

### **Week 5-6: ç”Ÿäº§éƒ¨ç½²**
- [ ] ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²
- [ ] ç°åº¦è¿ç§»RedFireä¸»æœåŠ¡
- [ ] ç›‘æ§å’Œå‘Šè­¦é…ç½®
- [ ] å®Œå…¨åˆ‡æ¢åˆ°æ–°é…ç½®ç³»ç»Ÿ

---

**è®¾è®¡å®Œæˆ**: âœ…  
**å®æ–½çŠ¶æ€**: ğŸ”„ è®¾è®¡é˜¶æ®µ  
**ä¸‹ä¸€æ­¥**: å¼€å§‹æ ¸å¿ƒä»£ç å®ç°
