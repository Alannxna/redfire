# 🔧 RedFire架构重构技术实施指南

## 📋 概述

本指南提供RedFire架构重构的具体技术实现步骤，包含代码示例、配置文件和最佳实践。

---

## 🚀 Phase 1: 保留核心，重构边缘

### **1.1 项目环境准备**

#### **开发环境配置**
```bash
# 创建虚拟环境
python -m venv redfire_env
source redfire_env/bin/activate  # Linux/Mac
# 或
redfire_env\Scripts\activate  # Windows

# 安装依赖
pip install -r requirements.txt
pip install -r requirements-dev.txt

# 配置开发环境
cp .env.example .env
# 编辑 .env 文件配置数据库等
```

#### **Docker环境配置**
```yaml
# docker-compose.dev.yml
version: '3.8'
services:
  backend:
    build: .
    ports:
      - "8000:8000"
    environment:
      - ENVIRONMENT=development
    volumes:
      - .:/app
    depends_on:
      - postgres
      - redis
  
  postgres:
    image: postgres:13
    environment:
      POSTGRES_DB: redfire_dev
      POSTGRES_USER: redfire
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

### **1.2 Legacy代码重构**

#### **重构old_utils模块**
```python
# 原代码: backend/legacy/old_utils/helpers.py
def format_money(amount):
    return f"${amount:.2f}"

def validate_email(email):
    import re
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None

# 重构后: backend/shared/utils/currency.py
from decimal import Decimal
from typing import Union
import locale

def format_currency(amount: Union[float, Decimal], currency: str = "USD") -> str:
    """格式化货币显示"""
    if currency == "USD":
        return f"${amount:,.2f}"
    elif currency == "CNY":
        return f"¥{amount:,.2f}"
    else:
        return f"{amount:,.2f} {currency}"

# 重构后: backend/shared/utils/validation.py
import re
from typing import Optional
from email_validator import validate_email as validate_email_lib, EmailNotValidError

def validate_email(email: str) -> tuple[bool, Optional[str]]:
    """验证邮箱格式"""
    try:
        validate_email_lib(email)
        return True, None
    except EmailNotValidError as e:
        return False, str(e)

def validate_phone(phone: str) -> bool:
    """验证手机号格式"""
    pattern = r'^1[3-9]\d{9}$'
    return re.match(pattern, phone) is not None
```

#### **重构old_data模块**
```python
# 原代码: backend/legacy/old_data/db_connector.py
import sqlite3

class DBConnector:
    def __init__(self, db_path):
        self.conn = sqlite3.connect(db_path)
    
    def execute_query(self, query, params=None):
        cursor = self.conn.cursor()
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        return cursor.fetchall()

# 重构后: backend/services/data/database.py
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import text
from typing import List, Dict, Any
import asyncio

Base = declarative_base()

class AsyncDatabaseService:
    def __init__(self, database_url: str):
        self.engine = create_async_engine(
            database_url,
            echo=False,
            pool_size=10,
            max_overflow=20
        )
        self.session_factory = sessionmaker(
            self.engine, class_=AsyncSession, expire_on_commit=False
        )
    
    async def get_session(self) -> AsyncSession:
        async with self.session_factory() as session:
            yield session
    
    async def execute_query(self, query: str, params: Dict[str, Any] = None) -> List[Dict[str, Any]]:
        """执行SQL查询"""
        async with self.session_factory() as session:
            result = await session.execute(text(query), params or {})
            return [dict(row) for row in result.fetchall()]
    
    async def execute_transaction(self, operations: List[callable]):
        """执行事务"""
        async with self.session_factory() as session:
            async with session.begin():
                for operation in operations:
                    await operation(session)
```

### **1.3 现代化功能模块开发**

#### **监控模块实现**
```python
# backend/core/monitoring/performance.py
import time
import logging
from functools import wraps
from typing import Callable, Any, Dict
from prometheus_client import Histogram, Counter

# 定义指标
REQUEST_DURATION = Histogram('http_request_duration_seconds', 'HTTP request duration')
REQUEST_COUNT = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint'])

def performance_monitor(func: Callable) -> Callable:
    """性能监控装饰器"""
    @wraps(func)
    async def wrapper(*args, **kwargs) -> Any:
        start_time = time.time()
        try:
            result = await func(*args, **kwargs)
            execution_time = time.time() - start_time
            
            # 记录性能指标
            REQUEST_DURATION.observe(execution_time)
            logging.info(f"{func.__name__} executed in {execution_time:.4f}s")
            
            return result
        except Exception as e:
            execution_time = time.time() - start_time
            logging.error(f"{func.__name__} failed after {execution_time:.4f}s: {e}")
            raise
    return wrapper

# backend/core/monitoring/health.py
from fastapi import APIRouter
from typing import Dict, Any
from datetime import datetime
import asyncio

router = APIRouter()

async def check_database_health() -> Dict[str, Any]:
    """检查数据库健康状态"""
    try:
        # 执行简单查询测试连接
        await database_service.execute_query("SELECT 1")
        return {"status": "healthy", "response_time": "10ms"}
    except Exception as e:
        return {"status": "unhealthy", "error": str(e)}

async def check_redis_health() -> Dict[str, Any]:
    """检查Redis健康状态"""
    try:
        await redis_client.ping()
        return {"status": "healthy"}
    except Exception as e:
        return {"status": "unhealthy", "error": str(e)}

@router.get("/health")
async def health_check() -> Dict[str, Any]:
    """健康检查接口"""
    health_checks = await asyncio.gather(
        check_database_health(),
        check_redis_health(),
        return_exceptions=True
    )
    
    return {
        "status": "healthy" if all(h.get("status") == "healthy" for h in health_checks) else "unhealthy",
        "timestamp": datetime.utcnow().isoformat(),
        "version": "1.0.0",
        "services": {
            "database": health_checks[0],
            "redis": health_checks[1]
        }
    }
```

#### **缓存模块实现**
```python
# backend/core/cache/redis_service.py
import redis.asyncio as redis
from typing import Optional, Any
import json
import pickle
from datetime import timedelta

class RedisCacheService:
    def __init__(self, redis_url: str):
        self.redis = redis.from_url(redis_url)
    
    async def get(self, key: str) -> Optional[Any]:
        """获取缓存数据"""
        try:
            data = await self.redis.get(key)
            if data:
                return pickle.loads(data)
            return None
        except Exception as e:
            logging.error(f"Redis get error: {e}")
            return None
    
    async def set(self, key: str, value: Any, expire: int = 3600):
        """设置缓存数据"""
        try:
            await self.redis.setex(key, expire, pickle.dumps(value))
        except Exception as e:
            logging.error(f"Redis set error: {e}")
    
    async def delete(self, key: str):
        """删除缓存数据"""
        try:
            await self.redis.delete(key)
        except Exception as e:
            logging.error(f"Redis delete error: {e}")
    
    async def exists(self, key: str) -> bool:
        """检查键是否存在"""
        try:
            return await self.redis.exists(key) > 0
        except Exception as e:
            logging.error(f"Redis exists error: {e}")
            return False

# backend/core/cache/strategies.py
from functools import wraps
from typing import Callable, Any
import hashlib

def cache_result(expire: int = 3600, key_prefix: str = ""):
    """缓存结果装饰器"""
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs) -> Any:
            # 生成缓存键
            cache_key = f"{key_prefix}:{func.__name__}:{hash(str(args) + str(kwargs))}"
            
            # 尝试从缓存获取
            cached_result = await cache_service.get(cache_key)
            if cached_result is not None:
                return cached_result
            
            # 执行函数并缓存结果
            result = await func(*args, **kwargs)
            await cache_service.set(cache_key, result, expire)
            return result
        return wrapper
    return decorator
```

---

## 🚀 Phase 2: 核心模块现代化

### **2.1 Core模块升级**

#### **应用生命周期管理**
```python
# backend/core/lifecycle/manager.py
from typing import Dict, Any, Callable, List
from enum import Enum
import asyncio
import logging

class LifecycleState(Enum):
    INITIALIZING = "initializing"
    STARTING = "starting"
    RUNNING = "running"
    STOPPING = "stopping"
    STOPPED = "stopped"
    ERROR = "error"

class ApplicationLifecycleManager:
    def __init__(self):
        self.state = LifecycleState.INITIALIZING
        self.startup_hooks: List[Callable] = []
        self.shutdown_hooks: List[Callable] = []
        self.logger = logging.getLogger(__name__)
    
    def add_startup_hook(self, hook: Callable):
        """添加启动钩子"""
        self.startup_hooks.append(hook)
    
    def add_shutdown_hook(self, hook: Callable):
        """添加关闭钩子"""
        self.shutdown_hooks.append(hook)
    
    async def startup(self):
        """应用启动流程"""
        self.state = LifecycleState.STARTING
        self.logger.info("Starting application...")
        
        try:
            for hook in self.startup_hooks:
                if asyncio.iscoroutinefunction(hook):
                    await hook()
                else:
                    hook()
            self.state = LifecycleState.RUNNING
            self.logger.info("Application started successfully")
        except Exception as e:
            self.state = LifecycleState.ERROR
            self.logger.error(f"Application startup failed: {e}")
            raise
    
    async def shutdown(self):
        """应用关闭流程"""
        self.state = LifecycleState.STOPPING
        self.logger.info("Shutting down application...")
        
        try:
            for hook in self.shutdown_hooks:
                if asyncio.iscoroutinefunction(hook):
                    await hook()
                else:
                    hook()
            self.state = LifecycleState.STOPPED
            self.logger.info("Application shutdown completed")
        except Exception as e:
            self.state = LifecycleState.ERROR
            self.logger.error(f"Application shutdown failed: {e}")
            raise
    
    def get_state(self) -> LifecycleState:
        """获取当前状态"""
        return self.state
```

#### **配置管理现代化**
```python
# backend/core/config/hierarchical.py
from pydantic import BaseSettings, validator
from typing import Dict, Any, Optional
import yaml
import os
from pathlib import Path

class DatabaseConfig(BaseSettings):
    url: str
    pool_size: int = 10
    max_overflow: int = 20
    echo: bool = False
    
    @validator('url')
    def validate_database_url(cls, v):
        if not v.startswith(('postgresql://', 'mysql://', 'sqlite://')):
            raise ValueError('Invalid database URL')
        return v

class RedisConfig(BaseSettings):
    url: str
    db: int = 0
    password: Optional[str] = None
    
    @validator('url')
    def validate_redis_url(cls, v):
        if not v.startswith('redis://'):
            raise ValueError('Invalid Redis URL')
        return v

class SecurityConfig(BaseSettings):
    secret_key: str
    algorithm: str = "HS256"
    access_token_expire_minutes: int = 30
    
    @validator('secret_key')
    def validate_secret_key(cls, v):
        if len(v) < 32:
            raise ValueError('Secret key must be at least 32 characters')
        return v

class AppConfig(BaseSettings):
    environment: str = "development"
    debug: bool = False
    host: str = "0.0.0.0"
    port: int = 8000
    log_level: str = "INFO"
    
    database: DatabaseConfig
    redis: RedisConfig
    security: SecurityConfig
    
    class Config:
        env_file = ".env"
        env_nested_delimiter = "__"

class ConfigManager:
    def __init__(self):
        self.config: Optional[AppConfig] = None
        self.config_files: List[str] = []
    
    def load_config(self, config_path: str = None):
        """加载配置"""
        if config_path and os.path.exists(config_path):
            with open(config_path, 'r') as f:
                config_data = yaml.safe_load(f)
            self.config = AppConfig(**config_data)
        else:
            self.config = AppConfig()
    
    def get_config(self) -> AppConfig:
        """获取配置"""
        if not self.config:
            self.load_config()
        return self.config
    
    def reload_config(self):
        """重新加载配置"""
        self.config = None
        return self.get_config()
```

### **2.2 数据库访问层优化**

#### **SQLAlchemy 2.0异步ORM**
```python
# backend/core/database/async_orm.py
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import DeclarativeBase, sessionmaker
from sqlalchemy import select, update, delete, text
from typing import TypeVar, Generic, Type, List, Optional, Any
import logging

Base = DeclarativeBase()
T = TypeVar('T', bound=Base)

class AsyncDatabaseManager:
    def __init__(self, database_url: str):
        self.engine = create_async_engine(
            database_url,
            echo=False,
            pool_size=20,
            max_overflow=30,
            pool_pre_ping=True,
            pool_recycle=3600
        )
        self.session_factory = sessionmaker(
            self.engine, class_=AsyncSession, expire_on_commit=False
        )
        self.logger = logging.getLogger(__name__)
    
    async def get_session(self) -> AsyncSession:
        """获取数据库会话"""
        async with self.session_factory() as session:
            yield session
    
    async def execute_query(self, query, params: Dict[str, Any] = None):
        """执行查询"""
        async with self.session_factory() as session:
            try:
                result = await session.execute(query, params or {})
                await session.commit()
                return result
            except Exception as e:
                await session.rollback()
                self.logger.error(f"Database query error: {e}")
                raise

class AsyncRepository(Generic[T]):
    def __init__(self, model: Type[T], db_manager: AsyncDatabaseManager):
        self.model = model
        self.db_manager = db_manager
    
    async def get_by_id(self, id: Any) -> Optional[T]:
        """根据ID获取记录"""
        async with self.db_manager.session_factory() as session:
            result = await session.execute(
                select(self.model).where(self.model.id == id)
            )
            return result.scalar_one_or_none()
    
    async def get_all(self, limit: int = 100, offset: int = 0) -> List[T]:
        """获取所有记录"""
        async with self.db_manager.session_factory() as session:
            result = await session.execute(
                select(self.model).limit(limit).offset(offset)
            )
            return result.scalars().all()
    
    async def create(self, **kwargs) -> T:
        """创建记录"""
        async with self.db_manager.session_factory() as session:
            instance = self.model(**kwargs)
            session.add(instance)
            await session.commit()
            await session.refresh(instance)
            return instance
    
    async def update(self, id: Any, **kwargs) -> Optional[T]:
        """更新记录"""
        async with self.db_manager.session_factory() as session:
            result = await session.execute(
                select(self.model).where(self.model.id == id)
            )
            instance = result.scalar_one_or_none()
            if instance:
                for key, value in kwargs.items():
                    setattr(instance, key, value)
                await session.commit()
                await session.refresh(instance)
            return instance
    
    async def delete(self, id: Any) -> bool:
        """删除记录"""
        async with self.db_manager.session_factory() as session:
            result = await session.execute(
                select(self.model).where(self.model.id == id)
            )
            instance = result.scalar_one_or_none()
            if instance:
                await session.delete(instance)
                await session.commit()
                return True
            return False
```

#### **数据模型重构**
```python
# backend/models/user.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Text
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from backend.core.database.async_orm import Base
from datetime import datetime

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, index=True, nullable=False)
    email = Column(String(100), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    full_name = Column(String(100))
    is_active = Column(Boolean, default=True)
    is_superuser = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # 关系
    orders = relationship("Order", back_populates="user")
    strategies = relationship("Strategy", back_populates="user")
    
    def __repr__(self):
        return f"<User(id={self.id}, username='{self.username}')>"

# backend/models/order.py
from sqlalchemy import Column, Integer, String, DateTime, Numeric, Enum
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from backend.core.database.async_orm import Base
import enum

class OrderStatus(enum.Enum):
    PENDING = "pending"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"

class OrderType(enum.Enum):
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"

class Order(Base):
    __tablename__ = "orders"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    order_type = Column(Enum(OrderType), nullable=False)
    side = Column(String(4), nullable=False)  # BUY/SELL
    quantity = Column(Numeric(10, 2), nullable=False)
    price = Column(Numeric(10, 4))
    status = Column(Enum(OrderStatus), default=OrderStatus.PENDING)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # 关系
    user = relationship("User", back_populates="orders")
    
    def __repr__(self):
        return f"<Order(id={self.id}, symbol='{self.symbol}', status='{self.status.value}')>"
```

---

## 🚀 Phase 3: 功能扩展

### **3.1 高级交易功能**

#### **策略引擎实现**
```python
# backend/services/strategy/engine.py
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
import asyncio
import logging
from datetime import datetime

class StrategyEngine:
    def __init__(self):
        self.strategies: Dict[str, BaseStrategy] = {}
        self.running = False
        self.logger = logging.getLogger(__name__)
    
    async def add_strategy(self, strategy_id: str, strategy: 'BaseStrategy'):
        """添加策略"""
        self.strategies[strategy_id] = strategy
        await strategy.initialize()
        self.logger.info(f"Strategy {strategy_id} added")
    
    async def start_strategy(self, strategy_id: str):
        """启动策略"""
        if strategy_id in self.strategies:
            strategy = self.strategies[strategy_id]
            await strategy.start()
            self.logger.info(f"Strategy {strategy_id} started")
        else:
            raise ValueError(f"Strategy {strategy_id} not found")
    
    async def stop_strategy(self, strategy_id: str):
        """停止策略"""
        if strategy_id in self.strategies:
            strategy = self.strategies[strategy_id]
            await strategy.stop()
            self.logger.info(f"Strategy {strategy_id} stopped")
        else:
            raise ValueError(f"Strategy {strategy_id} not found")
    
    async def get_strategy_status(self, strategy_id: str) -> Optional[Dict[str, Any]]:
        """获取策略状态"""
        if strategy_id in self.strategies:
            strategy = self.strategies[strategy_id]
            return await strategy.get_status()
        return None

class BaseStrategy(ABC):
    def __init__(self, strategy_id: str, config: Dict[str, Any]):
        self.strategy_id = strategy_id
        self.config = config
        self.running = False
        self.logger = logging.getLogger(f"strategy.{strategy_id}")
    
    @abstractmethod
    async def initialize(self):
        """策略初始化"""
        pass
    
    @abstractmethod
    async def start(self):
        """策略启动"""
        pass
    
    @abstractmethod
    async def stop(self):
        """策略停止"""
        pass
    
    @abstractmethod
    async def on_tick(self, tick_data: Dict[str, Any]):
        """处理tick数据"""
        pass
    
    async def get_status(self) -> Dict[str, Any]:
        """获取策略状态"""
        return {
            "strategy_id": self.strategy_id,
            "running": self.running,
            "config": self.config,
            "last_update": datetime.utcnow().isoformat()
        }

# 示例策略实现
class MovingAverageStrategy(BaseStrategy):
    async def initialize(self):
        """初始化移动平均策略"""
        self.fast_window = self.config.get("fast_window", 10)
        self.slow_window = self.config.get("slow_window", 20)
        self.position = 0
        self.logger.info(f"MovingAverageStrategy initialized with fast={self.fast_window}, slow={self.slow_window}")
    
    async def start(self):
        """启动策略"""
        self.running = True
        self.logger.info("MovingAverageStrategy started")
    
    async def stop(self):
        """停止策略"""
        self.running = False
        self.logger.info("MovingAverageStrategy stopped")
    
    async def on_tick(self, tick_data: Dict[str, Any]):
        """处理tick数据"""
        if not self.running:
            return
        
        # 计算移动平均
        fast_ma = self.calculate_ma(self.fast_window)
        slow_ma = self.calculate_ma(self.slow_window)
        
        # 交易信号
        if fast_ma > slow_ma and self.position <= 0:
            await self.place_order("BUY", tick_data["price"])
        elif fast_ma < slow_ma and self.position >= 0:
            await self.place_order("SELL", tick_data["price"])
    
    def calculate_ma(self, window: int) -> float:
        """计算移动平均"""
        # 实现移动平均计算逻辑
        pass
    
    async def place_order(self, side: str, price: float):
        """下单"""
        # 实现下单逻辑
        self.logger.info(f"Placing {side} order at {price}")
```

### **3.2 VnPy集成**

#### **VnPy引擎集成**
```python
# backend/services/vnpy/engine_v3.py
from vnpy.trader.engine import MainEngine
from vnpy.trader.object import TickData, OrderData, TradeData
from vnpy.trader.constant import Direction, OrderType
from typing import Dict, Any, Optional
import asyncio
import logging

class RedFireVnPyEngine:
    def __init__(self):
        self.main_engine = MainEngine()
        self.gateways = {}
        self.strategies = {}
        self.logger = logging.getLogger(__name__)
    
    async def initialize(self, config: Dict[str, Any]):
        """初始化VnPy引擎"""
        try:
            # 加载网关
            for gateway_name, gateway_config in config.get("gateways", {}).items():
                await self.load_gateway(gateway_name, gateway_config)
            
            # 加载策略
            for strategy_name, strategy_config in config.get("strategies", {}).items():
                await self.load_strategy(strategy_name, strategy_config)
            
            self.logger.info("VnPy engine initialized successfully")
        except Exception as e:
            self.logger.error(f"VnPy engine initialization failed: {e}")
            raise
    
    async def load_gateway(self, gateway_name: str, config: Dict[str, Any]):
        """加载交易网关"""
        try:
            # 根据配置动态加载网关
            gateway_class = self.get_gateway_class(gateway_name)
            gateway = gateway_class(self.main_engine, gateway_name)
            await gateway.connect(config)
            self.gateways[gateway_name] = gateway
            self.logger.info(f"Gateway {gateway_name} loaded successfully")
        except Exception as e:
            self.logger.error(f"Failed to load gateway {gateway_name}: {e}")
            raise
    
    async def load_strategy(self, strategy_name: str, config: Dict[str, Any]):
        """加载策略"""
        try:
            strategy_class = self.get_strategy_class(config["class"])
            strategy = strategy_class(self.main_engine, strategy_name)
            strategy.load_setting(config["setting"])
            self.strategies[strategy_name] = strategy
            self.logger.info(f"Strategy {strategy_name} loaded successfully")
        except Exception as e:
            self.logger.error(f"Failed to load strategy {strategy_name}: {e}")
            raise
    
    def get_gateway_class(self, gateway_name: str):
        """获取网关类"""
        # 实现网关类获取逻辑
        pass
    
    def get_strategy_class(self, strategy_class_name: str):
        """获取策略类"""
        # 实现策略类获取逻辑
        pass
    
    async def send_order(self, symbol: str, direction: Direction, 
                        order_type: OrderType, volume: float, 
                        price: float = 0.0, gateway_name: str = None) -> str:
        """发送订单"""
        try:
            if gateway_name and gateway_name in self.gateways:
                gateway = self.gateways[gateway_name]
                order_id = await gateway.send_order(symbol, direction, order_type, volume, price)
                self.logger.info(f"Order sent: {order_id}")
                return order_id
            else:
                raise ValueError(f"Gateway {gateway_name} not found")
        except Exception as e:
            self.logger.error(f"Failed to send order: {e}")
            raise
    
    async def cancel_order(self, order_id: str, gateway_name: str):
        """取消订单"""
        try:
            if gateway_name in self.gateways:
                gateway = self.gateways[gateway_name]
                await gateway.cancel_order(order_id)
                self.logger.info(f"Order cancelled: {order_id}")
            else:
                raise ValueError(f"Gateway {gateway_name} not found")
        except Exception as e:
            self.logger.error(f"Failed to cancel order: {e}")
            raise
```

---

## 📋 部署配置

### **Docker配置**
```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .
COPY requirements-dev.txt .

# 安装Python依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建非root用户
RUN useradd -m -u 1000 redfire && chown -R redfire:redfire /app
USER redfire

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["uvicorn", "backend.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### **Kubernetes配置**
```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redfire-backend
  namespace: redfire
spec:
  replicas: 3
  selector:
    matchLabels:
      app: redfire-backend
  template:
    metadata:
      labels:
        app: redfire-backend
    spec:
      containers:
      - name: redfire-backend
        image: redfire/backend:latest
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: redfire-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redfire-secrets
              key: redis-url
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: redfire-backend-service
  namespace: redfire
spec:
  selector:
    app: redfire-backend
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8000
  type: ClusterIP
```

---

## 📊 监控配置

### **Prometheus配置**
```yaml
# prometheus/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "rules/*.yml"

scrape_configs:
  - job_name: 'redfire-backend'
    static_configs:
      - targets: ['redfire-backend-service:80']
    metrics_path: '/metrics'
    scrape_interval: 5s

  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres-exporter:9187']

  - job_name: 'redis'
    static_configs:
      - targets: ['redis-exporter:9121']
```

### **Grafana仪表板**
```json
{
  "dashboard": {
    "title": "RedFire Trading Platform",
    "panels": [
      {
        "title": "API Response Time",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_request_duration_seconds_sum[5m]) / rate(http_request_duration_seconds_count[5m])",
            "legendFormat": "{{endpoint}}"
          }
        ]
      },
      {
        "title": "Active Strategies",
        "type": "stat",
        "targets": [
          {
            "expr": "active_strategies",
            "legendFormat": "Strategies"
          }
        ]
      },
      {
        "title": "Database Connections",
        "type": "graph",
        "targets": [
          {
            "expr": "pg_stat_database_numbackends",
            "legendFormat": "{{datname}}"
          }
        ]
      }
    ]
  }
}
```

---

**文档状态：** 草稿  
**最后更新：** 2024年1月1日  
**下次评审：** 2024年1月15日
