# ğŸ”§ RedFireæ¶æ„é‡æ„æŠ€æœ¯å®æ–½æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æŒ‡å—æä¾›RedFireæ¶æ„é‡æ„çš„å…·ä½“æŠ€æœ¯å®ç°æ­¥éª¤ï¼ŒåŒ…å«ä»£ç ç¤ºä¾‹ã€é…ç½®æ–‡ä»¶å’Œæœ€ä½³å®è·µã€‚

---

## ğŸš€ Phase 1: ä¿ç•™æ ¸å¿ƒï¼Œé‡æ„è¾¹ç¼˜

### **1.1 é¡¹ç›®ç¯å¢ƒå‡†å¤‡**

#### **å¼€å‘ç¯å¢ƒé…ç½®**
```bash
# åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ
python -m venv redfire_env
source redfire_env/bin/activate  # Linux/Mac
# æˆ–
redfire_env\Scripts\activate  # Windows

# å®‰è£…ä¾èµ–
pip install -r requirements.txt
pip install -r requirements-dev.txt

# é…ç½®å¼€å‘ç¯å¢ƒ
cp .env.example .env
# ç¼–è¾‘ .env æ–‡ä»¶é…ç½®æ•°æ®åº“ç­‰
```

#### **Dockerç¯å¢ƒé…ç½®**
```yaml
# docker-compose.dev.yml
version: '3.8'
services:
  backend:
    build: .
    ports:
      - "8000:8000"
    environment:
      - ENVIRONMENT=development
    volumes:
      - .:/app
    depends_on:
      - postgres
      - redis
  
  postgres:
    image: postgres:13
    environment:
      POSTGRES_DB: redfire_dev
      POSTGRES_USER: redfire
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

### **1.2 Legacyä»£ç é‡æ„**

#### **é‡æ„old_utilsæ¨¡å—**
```python
# åŸä»£ç : backend/legacy/old_utils/helpers.py
def format_money(amount):
    return f"${amount:.2f}"

def validate_email(email):
    import re
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None

# é‡æ„å: backend/shared/utils/currency.py
from decimal import Decimal
from typing import Union
import locale

def format_currency(amount: Union[float, Decimal], currency: str = "USD") -> str:
    """æ ¼å¼åŒ–è´§å¸æ˜¾ç¤º"""
    if currency == "USD":
        return f"${amount:,.2f}"
    elif currency == "CNY":
        return f"Â¥{amount:,.2f}"
    else:
        return f"{amount:,.2f} {currency}"

# é‡æ„å: backend/shared/utils/validation.py
import re
from typing import Optional
from email_validator import validate_email as validate_email_lib, EmailNotValidError

def validate_email(email: str) -> tuple[bool, Optional[str]]:
    """éªŒè¯é‚®ç®±æ ¼å¼"""
    try:
        validate_email_lib(email)
        return True, None
    except EmailNotValidError as e:
        return False, str(e)

def validate_phone(phone: str) -> bool:
    """éªŒè¯æ‰‹æœºå·æ ¼å¼"""
    pattern = r'^1[3-9]\d{9}$'
    return re.match(pattern, phone) is not None
```

#### **é‡æ„old_dataæ¨¡å—**
```python
# åŸä»£ç : backend/legacy/old_data/db_connector.py
import sqlite3

class DBConnector:
    def __init__(self, db_path):
        self.conn = sqlite3.connect(db_path)
    
    def execute_query(self, query, params=None):
        cursor = self.conn.cursor()
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        return cursor.fetchall()

# é‡æ„å: backend/services/data/database.py
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import text
from typing import List, Dict, Any
import asyncio

Base = declarative_base()

class AsyncDatabaseService:
    def __init__(self, database_url: str):
        self.engine = create_async_engine(
            database_url,
            echo=False,
            pool_size=10,
            max_overflow=20
        )
        self.session_factory = sessionmaker(
            self.engine, class_=AsyncSession, expire_on_commit=False
        )
    
    async def get_session(self) -> AsyncSession:
        async with self.session_factory() as session:
            yield session
    
    async def execute_query(self, query: str, params: Dict[str, Any] = None) -> List[Dict[str, Any]]:
        """æ‰§è¡ŒSQLæŸ¥è¯¢"""
        async with self.session_factory() as session:
            result = await session.execute(text(query), params or {})
            return [dict(row) for row in result.fetchall()]
    
    async def execute_transaction(self, operations: List[callable]):
        """æ‰§è¡Œäº‹åŠ¡"""
        async with self.session_factory() as session:
            async with session.begin():
                for operation in operations:
                    await operation(session)
```

### **1.3 ç°ä»£åŒ–åŠŸèƒ½æ¨¡å—å¼€å‘**

#### **ç›‘æ§æ¨¡å—å®ç°**
```python
# backend/core/monitoring/performance.py
import time
import logging
from functools import wraps
from typing import Callable, Any, Dict
from prometheus_client import Histogram, Counter

# å®šä¹‰æŒ‡æ ‡
REQUEST_DURATION = Histogram('http_request_duration_seconds', 'HTTP request duration')
REQUEST_COUNT = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint'])

def performance_monitor(func: Callable) -> Callable:
    """æ€§èƒ½ç›‘æ§è£…é¥°å™¨"""
    @wraps(func)
    async def wrapper(*args, **kwargs) -> Any:
        start_time = time.time()
        try:
            result = await func(*args, **kwargs)
            execution_time = time.time() - start_time
            
            # è®°å½•æ€§èƒ½æŒ‡æ ‡
            REQUEST_DURATION.observe(execution_time)
            logging.info(f"{func.__name__} executed in {execution_time:.4f}s")
            
            return result
        except Exception as e:
            execution_time = time.time() - start_time
            logging.error(f"{func.__name__} failed after {execution_time:.4f}s: {e}")
            raise
    return wrapper

# backend/core/monitoring/health.py
from fastapi import APIRouter
from typing import Dict, Any
from datetime import datetime
import asyncio

router = APIRouter()

async def check_database_health() -> Dict[str, Any]:
    """æ£€æŸ¥æ•°æ®åº“å¥åº·çŠ¶æ€"""
    try:
        # æ‰§è¡Œç®€å•æŸ¥è¯¢æµ‹è¯•è¿æ¥
        await database_service.execute_query("SELECT 1")
        return {"status": "healthy", "response_time": "10ms"}
    except Exception as e:
        return {"status": "unhealthy", "error": str(e)}

async def check_redis_health() -> Dict[str, Any]:
    """æ£€æŸ¥Rediså¥åº·çŠ¶æ€"""
    try:
        await redis_client.ping()
        return {"status": "healthy"}
    except Exception as e:
        return {"status": "unhealthy", "error": str(e)}

@router.get("/health")
async def health_check() -> Dict[str, Any]:
    """å¥åº·æ£€æŸ¥æ¥å£"""
    health_checks = await asyncio.gather(
        check_database_health(),
        check_redis_health(),
        return_exceptions=True
    )
    
    return {
        "status": "healthy" if all(h.get("status") == "healthy" for h in health_checks) else "unhealthy",
        "timestamp": datetime.utcnow().isoformat(),
        "version": "1.0.0",
        "services": {
            "database": health_checks[0],
            "redis": health_checks[1]
        }
    }
```

#### **ç¼“å­˜æ¨¡å—å®ç°**
```python
# backend/core/cache/redis_service.py
import redis.asyncio as redis
from typing import Optional, Any
import json
import pickle
from datetime import timedelta

class RedisCacheService:
    def __init__(self, redis_url: str):
        self.redis = redis.from_url(redis_url)
    
    async def get(self, key: str) -> Optional[Any]:
        """è·å–ç¼“å­˜æ•°æ®"""
        try:
            data = await self.redis.get(key)
            if data:
                return pickle.loads(data)
            return None
        except Exception as e:
            logging.error(f"Redis get error: {e}")
            return None
    
    async def set(self, key: str, value: Any, expire: int = 3600):
        """è®¾ç½®ç¼“å­˜æ•°æ®"""
        try:
            await self.redis.setex(key, expire, pickle.dumps(value))
        except Exception as e:
            logging.error(f"Redis set error: {e}")
    
    async def delete(self, key: str):
        """åˆ é™¤ç¼“å­˜æ•°æ®"""
        try:
            await self.redis.delete(key)
        except Exception as e:
            logging.error(f"Redis delete error: {e}")
    
    async def exists(self, key: str) -> bool:
        """æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨"""
        try:
            return await self.redis.exists(key) > 0
        except Exception as e:
            logging.error(f"Redis exists error: {e}")
            return False

# backend/core/cache/strategies.py
from functools import wraps
from typing import Callable, Any
import hashlib

def cache_result(expire: int = 3600, key_prefix: str = ""):
    """ç¼“å­˜ç»“æœè£…é¥°å™¨"""
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs) -> Any:
            # ç”Ÿæˆç¼“å­˜é”®
            cache_key = f"{key_prefix}:{func.__name__}:{hash(str(args) + str(kwargs))}"
            
            # å°è¯•ä»ç¼“å­˜è·å–
            cached_result = await cache_service.get(cache_key)
            if cached_result is not None:
                return cached_result
            
            # æ‰§è¡Œå‡½æ•°å¹¶ç¼“å­˜ç»“æœ
            result = await func(*args, **kwargs)
            await cache_service.set(cache_key, result, expire)
            return result
        return wrapper
    return decorator
```

---

## ğŸš€ Phase 2: æ ¸å¿ƒæ¨¡å—ç°ä»£åŒ–

### **2.1 Coreæ¨¡å—å‡çº§**

#### **åº”ç”¨ç”Ÿå‘½å‘¨æœŸç®¡ç†**
```python
# backend/core/lifecycle/manager.py
from typing import Dict, Any, Callable, List
from enum import Enum
import asyncio
import logging

class LifecycleState(Enum):
    INITIALIZING = "initializing"
    STARTING = "starting"
    RUNNING = "running"
    STOPPING = "stopping"
    STOPPED = "stopped"
    ERROR = "error"

class ApplicationLifecycleManager:
    def __init__(self):
        self.state = LifecycleState.INITIALIZING
        self.startup_hooks: List[Callable] = []
        self.shutdown_hooks: List[Callable] = []
        self.logger = logging.getLogger(__name__)
    
    def add_startup_hook(self, hook: Callable):
        """æ·»åŠ å¯åŠ¨é’©å­"""
        self.startup_hooks.append(hook)
    
    def add_shutdown_hook(self, hook: Callable):
        """æ·»åŠ å…³é—­é’©å­"""
        self.shutdown_hooks.append(hook)
    
    async def startup(self):
        """åº”ç”¨å¯åŠ¨æµç¨‹"""
        self.state = LifecycleState.STARTING
        self.logger.info("Starting application...")
        
        try:
            for hook in self.startup_hooks:
                if asyncio.iscoroutinefunction(hook):
                    await hook()
                else:
                    hook()
            self.state = LifecycleState.RUNNING
            self.logger.info("Application started successfully")
        except Exception as e:
            self.state = LifecycleState.ERROR
            self.logger.error(f"Application startup failed: {e}")
            raise
    
    async def shutdown(self):
        """åº”ç”¨å…³é—­æµç¨‹"""
        self.state = LifecycleState.STOPPING
        self.logger.info("Shutting down application...")
        
        try:
            for hook in self.shutdown_hooks:
                if asyncio.iscoroutinefunction(hook):
                    await hook()
                else:
                    hook()
            self.state = LifecycleState.STOPPED
            self.logger.info("Application shutdown completed")
        except Exception as e:
            self.state = LifecycleState.ERROR
            self.logger.error(f"Application shutdown failed: {e}")
            raise
    
    def get_state(self) -> LifecycleState:
        """è·å–å½“å‰çŠ¶æ€"""
        return self.state
```

#### **é…ç½®ç®¡ç†ç°ä»£åŒ–**
```python
# backend/core/config/hierarchical.py
from pydantic import BaseSettings, validator
from typing import Dict, Any, Optional
import yaml
import os
from pathlib import Path

class DatabaseConfig(BaseSettings):
    url: str
    pool_size: int = 10
    max_overflow: int = 20
    echo: bool = False
    
    @validator('url')
    def validate_database_url(cls, v):
        if not v.startswith(('postgresql://', 'mysql://', 'sqlite://')):
            raise ValueError('Invalid database URL')
        return v

class RedisConfig(BaseSettings):
    url: str
    db: int = 0
    password: Optional[str] = None
    
    @validator('url')
    def validate_redis_url(cls, v):
        if not v.startswith('redis://'):
            raise ValueError('Invalid Redis URL')
        return v

class SecurityConfig(BaseSettings):
    secret_key: str
    algorithm: str = "HS256"
    access_token_expire_minutes: int = 30
    
    @validator('secret_key')
    def validate_secret_key(cls, v):
        if len(v) < 32:
            raise ValueError('Secret key must be at least 32 characters')
        return v

class AppConfig(BaseSettings):
    environment: str = "development"
    debug: bool = False
    host: str = "0.0.0.0"
    port: int = 8000
    log_level: str = "INFO"
    
    database: DatabaseConfig
    redis: RedisConfig
    security: SecurityConfig
    
    class Config:
        env_file = ".env"
        env_nested_delimiter = "__"

class ConfigManager:
    def __init__(self):
        self.config: Optional[AppConfig] = None
        self.config_files: List[str] = []
    
    def load_config(self, config_path: str = None):
        """åŠ è½½é…ç½®"""
        if config_path and os.path.exists(config_path):
            with open(config_path, 'r') as f:
                config_data = yaml.safe_load(f)
            self.config = AppConfig(**config_data)
        else:
            self.config = AppConfig()
    
    def get_config(self) -> AppConfig:
        """è·å–é…ç½®"""
        if not self.config:
            self.load_config()
        return self.config
    
    def reload_config(self):
        """é‡æ–°åŠ è½½é…ç½®"""
        self.config = None
        return self.get_config()
```

### **2.2 æ•°æ®åº“è®¿é—®å±‚ä¼˜åŒ–**

#### **SQLAlchemy 2.0å¼‚æ­¥ORM**
```python
# backend/core/database/async_orm.py
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import DeclarativeBase, sessionmaker
from sqlalchemy import select, update, delete, text
from typing import TypeVar, Generic, Type, List, Optional, Any
import logging

Base = DeclarativeBase()
T = TypeVar('T', bound=Base)

class AsyncDatabaseManager:
    def __init__(self, database_url: str):
        self.engine = create_async_engine(
            database_url,
            echo=False,
            pool_size=20,
            max_overflow=30,
            pool_pre_ping=True,
            pool_recycle=3600
        )
        self.session_factory = sessionmaker(
            self.engine, class_=AsyncSession, expire_on_commit=False
        )
        self.logger = logging.getLogger(__name__)
    
    async def get_session(self) -> AsyncSession:
        """è·å–æ•°æ®åº“ä¼šè¯"""
        async with self.session_factory() as session:
            yield session
    
    async def execute_query(self, query, params: Dict[str, Any] = None):
        """æ‰§è¡ŒæŸ¥è¯¢"""
        async with self.session_factory() as session:
            try:
                result = await session.execute(query, params or {})
                await session.commit()
                return result
            except Exception as e:
                await session.rollback()
                self.logger.error(f"Database query error: {e}")
                raise

class AsyncRepository(Generic[T]):
    def __init__(self, model: Type[T], db_manager: AsyncDatabaseManager):
        self.model = model
        self.db_manager = db_manager
    
    async def get_by_id(self, id: Any) -> Optional[T]:
        """æ ¹æ®IDè·å–è®°å½•"""
        async with self.db_manager.session_factory() as session:
            result = await session.execute(
                select(self.model).where(self.model.id == id)
            )
            return result.scalar_one_or_none()
    
    async def get_all(self, limit: int = 100, offset: int = 0) -> List[T]:
        """è·å–æ‰€æœ‰è®°å½•"""
        async with self.db_manager.session_factory() as session:
            result = await session.execute(
                select(self.model).limit(limit).offset(offset)
            )
            return result.scalars().all()
    
    async def create(self, **kwargs) -> T:
        """åˆ›å»ºè®°å½•"""
        async with self.db_manager.session_factory() as session:
            instance = self.model(**kwargs)
            session.add(instance)
            await session.commit()
            await session.refresh(instance)
            return instance
    
    async def update(self, id: Any, **kwargs) -> Optional[T]:
        """æ›´æ–°è®°å½•"""
        async with self.db_manager.session_factory() as session:
            result = await session.execute(
                select(self.model).where(self.model.id == id)
            )
            instance = result.scalar_one_or_none()
            if instance:
                for key, value in kwargs.items():
                    setattr(instance, key, value)
                await session.commit()
                await session.refresh(instance)
            return instance
    
    async def delete(self, id: Any) -> bool:
        """åˆ é™¤è®°å½•"""
        async with self.db_manager.session_factory() as session:
            result = await session.execute(
                select(self.model).where(self.model.id == id)
            )
            instance = result.scalar_one_or_none()
            if instance:
                await session.delete(instance)
                await session.commit()
                return True
            return False
```

#### **æ•°æ®æ¨¡å‹é‡æ„**
```python
# backend/models/user.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Text
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from backend.core.database.async_orm import Base
from datetime import datetime

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, index=True, nullable=False)
    email = Column(String(100), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    full_name = Column(String(100))
    is_active = Column(Boolean, default=True)
    is_superuser = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # å…³ç³»
    orders = relationship("Order", back_populates="user")
    strategies = relationship("Strategy", back_populates="user")
    
    def __repr__(self):
        return f"<User(id={self.id}, username='{self.username}')>"

# backend/models/order.py
from sqlalchemy import Column, Integer, String, DateTime, Numeric, Enum
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from backend.core.database.async_orm import Base
import enum

class OrderStatus(enum.Enum):
    PENDING = "pending"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"

class OrderType(enum.Enum):
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"

class Order(Base):
    __tablename__ = "orders"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    order_type = Column(Enum(OrderType), nullable=False)
    side = Column(String(4), nullable=False)  # BUY/SELL
    quantity = Column(Numeric(10, 2), nullable=False)
    price = Column(Numeric(10, 4))
    status = Column(Enum(OrderStatus), default=OrderStatus.PENDING)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # å…³ç³»
    user = relationship("User", back_populates="orders")
    
    def __repr__(self):
        return f"<Order(id={self.id}, symbol='{self.symbol}', status='{self.status.value}')>"
```

---

## ğŸš€ Phase 3: åŠŸèƒ½æ‰©å±•

### **3.1 é«˜çº§äº¤æ˜“åŠŸèƒ½**

#### **ç­–ç•¥å¼•æ“å®ç°**
```python
# backend/services/strategy/engine.py
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
import asyncio
import logging
from datetime import datetime

class StrategyEngine:
    def __init__(self):
        self.strategies: Dict[str, BaseStrategy] = {}
        self.running = False
        self.logger = logging.getLogger(__name__)
    
    async def add_strategy(self, strategy_id: str, strategy: 'BaseStrategy'):
        """æ·»åŠ ç­–ç•¥"""
        self.strategies[strategy_id] = strategy
        await strategy.initialize()
        self.logger.info(f"Strategy {strategy_id} added")
    
    async def start_strategy(self, strategy_id: str):
        """å¯åŠ¨ç­–ç•¥"""
        if strategy_id in self.strategies:
            strategy = self.strategies[strategy_id]
            await strategy.start()
            self.logger.info(f"Strategy {strategy_id} started")
        else:
            raise ValueError(f"Strategy {strategy_id} not found")
    
    async def stop_strategy(self, strategy_id: str):
        """åœæ­¢ç­–ç•¥"""
        if strategy_id in self.strategies:
            strategy = self.strategies[strategy_id]
            await strategy.stop()
            self.logger.info(f"Strategy {strategy_id} stopped")
        else:
            raise ValueError(f"Strategy {strategy_id} not found")
    
    async def get_strategy_status(self, strategy_id: str) -> Optional[Dict[str, Any]]:
        """è·å–ç­–ç•¥çŠ¶æ€"""
        if strategy_id in self.strategies:
            strategy = self.strategies[strategy_id]
            return await strategy.get_status()
        return None

class BaseStrategy(ABC):
    def __init__(self, strategy_id: str, config: Dict[str, Any]):
        self.strategy_id = strategy_id
        self.config = config
        self.running = False
        self.logger = logging.getLogger(f"strategy.{strategy_id}")
    
    @abstractmethod
    async def initialize(self):
        """ç­–ç•¥åˆå§‹åŒ–"""
        pass
    
    @abstractmethod
    async def start(self):
        """ç­–ç•¥å¯åŠ¨"""
        pass
    
    @abstractmethod
    async def stop(self):
        """ç­–ç•¥åœæ­¢"""
        pass
    
    @abstractmethod
    async def on_tick(self, tick_data: Dict[str, Any]):
        """å¤„ç†tickæ•°æ®"""
        pass
    
    async def get_status(self) -> Dict[str, Any]:
        """è·å–ç­–ç•¥çŠ¶æ€"""
        return {
            "strategy_id": self.strategy_id,
            "running": self.running,
            "config": self.config,
            "last_update": datetime.utcnow().isoformat()
        }

# ç¤ºä¾‹ç­–ç•¥å®ç°
class MovingAverageStrategy(BaseStrategy):
    async def initialize(self):
        """åˆå§‹åŒ–ç§»åŠ¨å¹³å‡ç­–ç•¥"""
        self.fast_window = self.config.get("fast_window", 10)
        self.slow_window = self.config.get("slow_window", 20)
        self.position = 0
        self.logger.info(f"MovingAverageStrategy initialized with fast={self.fast_window}, slow={self.slow_window}")
    
    async def start(self):
        """å¯åŠ¨ç­–ç•¥"""
        self.running = True
        self.logger.info("MovingAverageStrategy started")
    
    async def stop(self):
        """åœæ­¢ç­–ç•¥"""
        self.running = False
        self.logger.info("MovingAverageStrategy stopped")
    
    async def on_tick(self, tick_data: Dict[str, Any]):
        """å¤„ç†tickæ•°æ®"""
        if not self.running:
            return
        
        # è®¡ç®—ç§»åŠ¨å¹³å‡
        fast_ma = self.calculate_ma(self.fast_window)
        slow_ma = self.calculate_ma(self.slow_window)
        
        # äº¤æ˜“ä¿¡å·
        if fast_ma > slow_ma and self.position <= 0:
            await self.place_order("BUY", tick_data["price"])
        elif fast_ma < slow_ma and self.position >= 0:
            await self.place_order("SELL", tick_data["price"])
    
    def calculate_ma(self, window: int) -> float:
        """è®¡ç®—ç§»åŠ¨å¹³å‡"""
        # å®ç°ç§»åŠ¨å¹³å‡è®¡ç®—é€»è¾‘
        pass
    
    async def place_order(self, side: str, price: float):
        """ä¸‹å•"""
        # å®ç°ä¸‹å•é€»è¾‘
        self.logger.info(f"Placing {side} order at {price}")
```

### **3.2 VnPyé›†æˆ**

#### **VnPyå¼•æ“é›†æˆ**
```python
# backend/services/vnpy/engine_v3.py
from vnpy.trader.engine import MainEngine
from vnpy.trader.object import TickData, OrderData, TradeData
from vnpy.trader.constant import Direction, OrderType
from typing import Dict, Any, Optional
import asyncio
import logging

class RedFireVnPyEngine:
    def __init__(self):
        self.main_engine = MainEngine()
        self.gateways = {}
        self.strategies = {}
        self.logger = logging.getLogger(__name__)
    
    async def initialize(self, config: Dict[str, Any]):
        """åˆå§‹åŒ–VnPyå¼•æ“"""
        try:
            # åŠ è½½ç½‘å…³
            for gateway_name, gateway_config in config.get("gateways", {}).items():
                await self.load_gateway(gateway_name, gateway_config)
            
            # åŠ è½½ç­–ç•¥
            for strategy_name, strategy_config in config.get("strategies", {}).items():
                await self.load_strategy(strategy_name, strategy_config)
            
            self.logger.info("VnPy engine initialized successfully")
        except Exception as e:
            self.logger.error(f"VnPy engine initialization failed: {e}")
            raise
    
    async def load_gateway(self, gateway_name: str, config: Dict[str, Any]):
        """åŠ è½½äº¤æ˜“ç½‘å…³"""
        try:
            # æ ¹æ®é…ç½®åŠ¨æ€åŠ è½½ç½‘å…³
            gateway_class = self.get_gateway_class(gateway_name)
            gateway = gateway_class(self.main_engine, gateway_name)
            await gateway.connect(config)
            self.gateways[gateway_name] = gateway
            self.logger.info(f"Gateway {gateway_name} loaded successfully")
        except Exception as e:
            self.logger.error(f"Failed to load gateway {gateway_name}: {e}")
            raise
    
    async def load_strategy(self, strategy_name: str, config: Dict[str, Any]):
        """åŠ è½½ç­–ç•¥"""
        try:
            strategy_class = self.get_strategy_class(config["class"])
            strategy = strategy_class(self.main_engine, strategy_name)
            strategy.load_setting(config["setting"])
            self.strategies[strategy_name] = strategy
            self.logger.info(f"Strategy {strategy_name} loaded successfully")
        except Exception as e:
            self.logger.error(f"Failed to load strategy {strategy_name}: {e}")
            raise
    
    def get_gateway_class(self, gateway_name: str):
        """è·å–ç½‘å…³ç±»"""
        # å®ç°ç½‘å…³ç±»è·å–é€»è¾‘
        pass
    
    def get_strategy_class(self, strategy_class_name: str):
        """è·å–ç­–ç•¥ç±»"""
        # å®ç°ç­–ç•¥ç±»è·å–é€»è¾‘
        pass
    
    async def send_order(self, symbol: str, direction: Direction, 
                        order_type: OrderType, volume: float, 
                        price: float = 0.0, gateway_name: str = None) -> str:
        """å‘é€è®¢å•"""
        try:
            if gateway_name and gateway_name in self.gateways:
                gateway = self.gateways[gateway_name]
                order_id = await gateway.send_order(symbol, direction, order_type, volume, price)
                self.logger.info(f"Order sent: {order_id}")
                return order_id
            else:
                raise ValueError(f"Gateway {gateway_name} not found")
        except Exception as e:
            self.logger.error(f"Failed to send order: {e}")
            raise
    
    async def cancel_order(self, order_id: str, gateway_name: str):
        """å–æ¶ˆè®¢å•"""
        try:
            if gateway_name in self.gateways:
                gateway = self.gateways[gateway_name]
                await gateway.cancel_order(order_id)
                self.logger.info(f"Order cancelled: {order_id}")
            else:
                raise ValueError(f"Gateway {gateway_name} not found")
        except Exception as e:
            self.logger.error(f"Failed to cancel order: {e}")
            raise
```

---

## ğŸ“‹ éƒ¨ç½²é…ç½®

### **Dockeré…ç½®**
```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY requirements.txt .
COPY requirements-dev.txt .

# å®‰è£…Pythonä¾èµ–
RUN pip install --no-cache-dir -r requirements.txt

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# åˆ›å»ºérootç”¨æˆ·
RUN useradd -m -u 1000 redfire && chown -R redfire:redfire /app
USER redfire

# æš´éœ²ç«¯å£
EXPOSE 8000

# å¯åŠ¨å‘½ä»¤
CMD ["uvicorn", "backend.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### **Kubernetesé…ç½®**
```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redfire-backend
  namespace: redfire
spec:
  replicas: 3
  selector:
    matchLabels:
      app: redfire-backend
  template:
    metadata:
      labels:
        app: redfire-backend
    spec:
      containers:
      - name: redfire-backend
        image: redfire/backend:latest
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: redfire-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redfire-secrets
              key: redis-url
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: redfire-backend-service
  namespace: redfire
spec:
  selector:
    app: redfire-backend
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8000
  type: ClusterIP
```

---

## ğŸ“Š ç›‘æ§é…ç½®

### **Prometheusé…ç½®**
```yaml
# prometheus/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "rules/*.yml"

scrape_configs:
  - job_name: 'redfire-backend'
    static_configs:
      - targets: ['redfire-backend-service:80']
    metrics_path: '/metrics'
    scrape_interval: 5s

  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres-exporter:9187']

  - job_name: 'redis'
    static_configs:
      - targets: ['redis-exporter:9121']
```

### **Grafanaä»ªè¡¨æ¿**
```json
{
  "dashboard": {
    "title": "RedFire Trading Platform",
    "panels": [
      {
        "title": "API Response Time",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_request_duration_seconds_sum[5m]) / rate(http_request_duration_seconds_count[5m])",
            "legendFormat": "{{endpoint}}"
          }
        ]
      },
      {
        "title": "Active Strategies",
        "type": "stat",
        "targets": [
          {
            "expr": "active_strategies",
            "legendFormat": "Strategies"
          }
        ]
      },
      {
        "title": "Database Connections",
        "type": "graph",
        "targets": [
          {
            "expr": "pg_stat_database_numbackends",
            "legendFormat": "{{datname}}"
          }
        ]
      }
    ]
  }
}
```

---

**æ–‡æ¡£çŠ¶æ€ï¼š** è‰ç¨¿  
**æœ€åæ›´æ–°ï¼š** 2024å¹´1æœˆ1æ—¥  
**ä¸‹æ¬¡è¯„å®¡ï¼š** 2024å¹´1æœˆ15æ—¥
