# 📡 TODO-05: 微服务间通信机制

## 🎯 任务概述

**任务ID**: micro_03  
**优先级**: 高  
**预估工期**: 3-4天  
**负责模块**: 微服务架构

### 问题描述
实现微服务间的WebSocket实时通信和HTTP API调用机制，确保5个微服务之间能够高效、可靠地进行数据交换和事件通知。

## 🔍 现状分析

### 当前通信机制问题

#### 1. 缺乏统一的通信框架
```python
# 当前分散的服务调用方式
# 在不同模块中硬编码的HTTP调用
import requests

def call_vnpy_service():
    response = requests.get("http://localhost:8006/api/status")
    return response.json()

def call_user_service():
    # 重复的HTTP客户端逻辑
    response = requests.post("http://localhost:8001/api/users", json=data)
    
# 问题:
# - HTTP客户端逻辑重复
# - 错误处理不统一
# - 缺乏重试机制
# - 没有服务发现集成
```

#### 2. WebSocket实现不完整
```python
# backend/legacy/interfaces/rest/middleware/websocket_auth_middleware.py
class WebSocketAuthMiddleware:
    # 基础WebSocket认证，但缺乏:
    # - 消息路由机制
    # - 服务间WebSocket通信
    # - 消息持久化
    # - 连接管理
```

#### 3. 事件驱动架构不完善
```python
# backend/core/tradingEngine/eventEngine.py
class EventTradingEngine:
    def __init__(self):
        self.eventQueue = Queue()  # 本地队列
        self.eventHandlers = {}
    
    # 问题:
    # - 只支持本地事件
    # - 无法跨服务传播事件
    # - 缺乏事件持久化
    # - 没有事件溯源
```

### 架构缺陷

#### 1. 服务间依赖不清晰
```
VnPy核心服务 (8006) ←→ ?
用户交易服务 (8001) ←→ ?  
策略数据服务 (8002) ←→ ?
网关适配服务 (8004) ←→ ?
监控通知服务 (8005) ←→ ?

问题:
- 服务间调用关系不明确
- 循环依赖风险
- 数据一致性保障缺失
```

#### 2. 实时数据同步机制缺失
- 市场数据无法实时分发到所有服务
- 交易状态更新延迟
- 策略信号传递不及时

## 🎨 设计方案

### 1. 统一服务通信框架

```python
# shared/communication/service_client.py
class ServiceClient:
    """统一服务客户端"""
    
    def __init__(self, service_name: str, config: CommunicationConfig):
        self.service_name = service_name
        self.config = config
        self.session = aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=30),
            connector=aiohttp.TCPConnector(limit=100)
        )
        self.circuit_breaker = CircuitBreaker(
            failure_threshold=5,
            recovery_timeout=60
        )
        self.service_discovery = ServiceDiscovery(config.discovery)
        
    async def call(self, endpoint: str, method: str = "GET", 
                   data: Any = None, headers: Dict = None) -> ServiceResponse:
        """统一服务调用接口"""
        
        # 1. 服务发现
        service_url = await self.service_discovery.get_service_url(self.service_name)
        if not service_url:
            raise ServiceUnavailableError(f"服务不可用: {self.service_name}")
        
        # 2. 构建请求
        url = f"{service_url}{endpoint}"
        request_headers = self._build_headers(headers)
        
        # 3. 熔断器保护
        if self.circuit_breaker.is_open():
            raise CircuitBreakerError("服务熔断器开启")
        
        # 4. 执行请求
        try:
            async with self.session.request(
                method=method,
                url=url,
                json=data,
                headers=request_headers
            ) as response:
                
                result = ServiceResponse(
                    status_code=response.status,
                    data=await response.json() if response.content_type == 'application/json' else await response.text(),
                    headers=dict(response.headers)
                )
                
                # 5. 记录成功调用
                self.circuit_breaker.record_success()
                return result
                
        except Exception as e:
            # 6. 记录失败并重试
            self.circuit_breaker.record_failure()
            raise ServiceCallError(f"服务调用失败: {e}")
    
    def _build_headers(self, custom_headers: Dict = None) -> Dict:
        """构建请求头"""
        headers = {
            "Content-Type": "application/json",
            "X-Service-Name": self.service_name,
            "X-Request-ID": str(uuid.uuid4()),
            "X-Timestamp": datetime.utcnow().isoformat()
        }
        
        # 添加服务间认证
        auth_token = self._get_service_auth_token()
        if auth_token:
            headers["Authorization"] = f"Bearer {auth_token}"
        
        if custom_headers:
            headers.update(custom_headers)
        
        return headers

# shared/communication/service_registry.py
class ServiceRegistry:
    """服务注册表"""
    
    def __init__(self, redis_client: Redis):
        self.redis = redis_client
        self.service_prefix = "redfire:services"
        
    async def register_service(self, service: ServiceInfo) -> bool:
        """注册服务"""
        service_key = f"{self.service_prefix}:{service.name}"
        service_data = {
            "host": service.host,
            "port": service.port,
            "version": service.version,
            "status": service.status.value,
            "last_heartbeat": datetime.utcnow().isoformat(),
            "metadata": json.dumps(service.metadata)
        }
        
        # 设置服务信息，TTL 60秒
        await self.redis.hset(service_key, mapping=service_data)
        await self.redis.expire(service_key, 60)
        
        return True
    
    async def discover_services(self, service_name: str) -> List[ServiceInfo]:
        """发现服务实例"""
        service_key = f"{self.service_prefix}:{service_name}"
        service_data = await self.redis.hgetall(service_key)
        
        if not service_data:
            return []
        
        return [ServiceInfo(
            name=service_name,
            host=service_data["host"],
            port=int(service_data["port"]),
            version=service_data["version"],
            status=ServiceStatus(service_data["status"]),
            metadata=json.loads(service_data.get("metadata", "{}"))
        )]
```

### 2. WebSocket消息总线

```python
# shared/communication/websocket_bus.py
class WebSocketMessageBus:
    """WebSocket消息总线"""
    
    def __init__(self, redis_client: Redis):
        self.redis = redis_client
        self.connections: Dict[str, WebSocketConnection] = {}
        self.subscriptions: Dict[str, Set[str]] = {}  # topic -> connection_ids
        self.message_handlers: Dict[str, Callable] = {}
        
    async def connect(self, websocket: WebSocket, connection_id: str, 
                     user_context: Optional[UserContext] = None):
        """建立WebSocket连接"""
        await websocket.accept()
        
        connection = WebSocketConnection(
            id=connection_id,
            websocket=websocket,
            user_context=user_context,
            connected_at=datetime.utcnow()
        )
        
        self.connections[connection_id] = connection
        logger.info(f"WebSocket连接建立: {connection_id}")
        
        try:
            # 处理消息循环
            async for message in websocket.iter_text():
                await self._handle_message(connection_id, message)
        except WebSocketDisconnect:
            await self.disconnect(connection_id)
    
    async def disconnect(self, connection_id: str):
        """断开WebSocket连接"""
        if connection_id in self.connections:
            # 取消所有订阅
            topics_to_unsubscribe = [
                topic for topic, conn_ids in self.subscriptions.items()
                if connection_id in conn_ids
            ]
            
            for topic in topics_to_unsubscribe:
                await self.unsubscribe(connection_id, topic)
            
            # 移除连接
            del self.connections[connection_id]
            logger.info(f"WebSocket连接断开: {connection_id}")
    
    async def subscribe(self, connection_id: str, topic: str):
        """订阅主题"""
        if topic not in self.subscriptions:
            self.subscriptions[topic] = set()
        
        self.subscriptions[topic].add(connection_id)
        
        # 订阅Redis频道
        await self.redis.sadd(f"ws:subscriptions:{topic}", connection_id)
        
        logger.info(f"订阅主题: {connection_id} -> {topic}")
    
    async def publish(self, topic: str, message: Dict[str, Any], 
                     exclude_connection: Optional[str] = None):
        """发布消息到主题"""
        message_data = {
            "topic": topic,
            "payload": message,
            "timestamp": datetime.utcnow().isoformat(),
            "message_id": str(uuid.uuid4())
        }
        
        # 发布到Redis
        await self.redis.publish(f"ws:topic:{topic}", json.dumps(message_data))
        
        # 本地分发
        if topic in self.subscriptions:
            for connection_id in self.subscriptions[topic]:
                if connection_id != exclude_connection:
                    await self._send_to_connection(connection_id, message_data)
    
    async def _handle_message(self, connection_id: str, message: str):
        """处理WebSocket消息"""
        try:
            data = json.loads(message)
            message_type = data.get("type")
            
            if message_type == "subscribe":
                await self.subscribe(connection_id, data["topic"])
            elif message_type == "unsubscribe":
                await self.unsubscribe(connection_id, data["topic"])
            elif message_type == "publish":
                await self.publish(data["topic"], data["payload"], connection_id)
            elif message_type in self.message_handlers:
                await self.message_handlers[message_type](connection_id, data)
            else:
                logger.warning(f"未知消息类型: {message_type}")
                
        except Exception as e:
            logger.error(f"消息处理失败: {e}")
            await self._send_error(connection_id, str(e))
```

### 3. 事件驱动架构

```python
# shared/events/event_bus.py
class EventBus:
    """分布式事件总线"""
    
    def __init__(self, redis_client: Redis, service_name: str):
        self.redis = redis_client
        self.service_name = service_name
        self.event_handlers: Dict[str, List[Callable]] = {}
        self.event_store = EventStore(redis_client)
        
    async def publish_event(self, event: DomainEvent):
        """发布领域事件"""
        # 1. 事件持久化
        await self.event_store.save_event(event)
        
        # 2. 发布到Redis Stream
        stream_name = f"events:{event.event_type}"
        event_data = {
            "event_id": event.event_id,
            "event_type": event.event_type,
            "aggregate_id": event.aggregate_id,
            "payload": json.dumps(event.payload),
            "timestamp": event.timestamp.isoformat(),
            "version": event.version,
            "service_name": self.service_name
        }
        
        await self.redis.xadd(stream_name, event_data)
        logger.info(f"事件已发布: {event.event_type}#{event.event_id}")
    
    async def subscribe_to_events(self, event_types: List[str]):
        """订阅事件"""
        for event_type in event_types:
            stream_name = f"events:{event_type}"
            
            # 创建消费者组
            try:
                await self.redis.xgroup_create(
                    stream_name, 
                    self.service_name, 
                    id='0', 
                    mkstream=True
                )
            except Exception:
                pass  # 组已存在
        
        # 启动事件监听器
        asyncio.create_task(self._event_listener(event_types))
    
    async def _event_listener(self, event_types: List[str]):
        """事件监听器"""
        streams = {f"events:{event_type}": ">" for event_type in event_types}
        
        while True:
            try:
                events = await self.redis.xreadgroup(
                    self.service_name,
                    f"{self.service_name}-{uuid.uuid4().hex[:8]}",
                    streams,
                    count=10,
                    block=1000
                )
                
                for stream, event_list in events:
                    for event_id, event_data in event_list:
                        await self._handle_event(event_id, event_data)
                        
            except Exception as e:
                logger.error(f"事件监听错误: {e}")
                await asyncio.sleep(1)
    
    async def _handle_event(self, event_id: str, event_data: Dict):
        """处理事件"""
        try:
            event_type = event_data[b"event_type"].decode()
            
            if event_type in self.event_handlers:
                for handler in self.event_handlers[event_type]:
                    await handler(DomainEvent.from_dict(event_data))
                    
        except Exception as e:
            logger.error(f"事件处理失败 {event_id}: {e}")

# shared/events/domain_events.py
@dataclass  
class DomainEvent:
    """领域事件基类"""
    event_id: str
    event_type: str
    aggregate_id: str
    payload: Dict[str, Any]
    timestamp: datetime
    version: int = 1
    
    @classmethod
    def create(cls, event_type: str, aggregate_id: str, payload: Dict[str, Any]):
        return cls(
            event_id=str(uuid.uuid4()),
            event_type=event_type,
            aggregate_id=aggregate_id,
            payload=payload,
            timestamp=datetime.utcnow()
        )

# 具体事件定义
class OrderCreatedEvent(DomainEvent):
    """订单创建事件"""
    pass

class MarketDataUpdatedEvent(DomainEvent):
    """市场数据更新事件"""
    pass

class StrategySignalEvent(DomainEvent):
    """策略信号事件"""
    pass
```

### 4. 服务间API调用规范

```python
# shared/communication/service_apis.py
class VnPyCoreServiceAPI:
    """VnPy核心服务API客户端"""
    
    def __init__(self, client: ServiceClient):
        self.client = client
    
    async def get_trading_status(self) -> TradingStatus:
        """获取交易状态"""
        response = await self.client.call("/api/v1/trading/status")
        return TradingStatus.from_dict(response.data)
    
    async def submit_order(self, order: OrderRequest) -> OrderResponse:
        """提交订单"""
        response = await self.client.call(
            "/api/v1/orders",
            method="POST",
            data=order.to_dict()
        )
        return OrderResponse.from_dict(response.data)
    
    async def get_positions(self) -> List[Position]:
        """获取持仓"""
        response = await self.client.call("/api/v1/positions")
        return [Position.from_dict(pos) for pos in response.data]

class UserTradingServiceAPI:
    """用户交易服务API客户端"""
    
    def __init__(self, client: ServiceClient):
        self.client = client
    
    async def authenticate_user(self, token: str) -> UserInfo:
        """用户认证"""
        response = await self.client.call(
            "/api/v1/auth/verify",
            method="POST",
            data={"token": token}
        )
        return UserInfo.from_dict(response.data)
    
    async def get_user_permissions(self, user_id: str) -> List[str]:
        """获取用户权限"""
        response = await self.client.call(f"/api/v1/users/{user_id}/permissions")
        return response.data["permissions"]

class StrategyDataServiceAPI:
    """策略数据服务API客户端"""
    
    def __init__(self, client: ServiceClient):
        self.client = client
    
    async def get_strategy_list(self, user_id: str) -> List[Strategy]:
        """获取策略列表"""
        response = await self.client.call(
            f"/api/v1/strategies",
            headers={"X-User-ID": user_id}
        )
        return [Strategy.from_dict(s) for s in response.data]
    
    async def start_strategy(self, strategy_id: str) -> bool:
        """启动策略"""
        response = await self.client.call(
            f"/api/v1/strategies/{strategy_id}/start",
            method="POST"
        )
        return response.data["success"]
```

## 🔧 实施步骤

### 阶段1: 通信框架搭建 (2天)

1. **创建共享通信库**
   ```bash
   mkdir -p shared/communication
   mkdir -p shared/events
   ```

2. **实现ServiceClient基础功能**
   - HTTP客户端封装
   - 熔断器集成
   - 重试机制

3. **服务发现机制**
   - Redis服务注册表
   - 健康检查集成
   - 负载均衡

### 阶段2: WebSocket消息总线 (1天)

1. **WebSocket连接管理**
   - 连接池管理
   - 认证集成
   - 心跳检测

2. **消息路由机制**
   - 主题订阅
   - 消息分发
   - 跨服务消息传递

### 阶段3: 事件驱动架构 (1天)

1. **事件总线实现**
   - Redis Stream集成
   - 事件持久化
   - 消费者组管理

2. **领域事件定义**
   - 核心业务事件
   - 事件处理器
   - 事件溯源

## 📊 验收标准

### 功能验收
- [ ] 服务间HTTP调用正常
- [ ] WebSocket实时通信工作
- [ ] 事件发布订阅机制
- [ ] 服务发现和注册

### 性能指标
- [ ] 服务间调用延迟 < 100ms
- [ ] WebSocket消息延迟 < 50ms
- [ ] 事件处理延迟 < 200ms
- [ ] 并发连接数 > 1000

### 可靠性标准
- [ ] 熔断器保护生效
- [ ] 自动重试机制
- [ ] 消息不丢失
- [ ] 连接自动恢复

## 🚨 风险评估

### 高风险
- **网络分区**: 服务间通信中断
- **消息丢失**: 事件或消息丢失

### 中风险
- **性能瓶颈**: Redis成为瓶颈
- **内存泄漏**: WebSocket连接泄漏

### 缓解措施
1. **多重保障**: 多种通信方式备份
2. **监控告警**: 全链路监控
3. **资源管理**: 连接池和内存管理

## 📈 预期收益

### 短期收益
- 服务间通信标准化
- 实时数据传输能力
- 系统响应性提升

### 长期收益
- 事件驱动架构完善
- 系统扩展性增强
- 微服务治理基础

## 📝 相关文档

- [微服务通信模式](../architecture/microservice-communication.md)
- [WebSocket最佳实践](../development/websocket-guide.md)
- [事件驱动架构指南](../architecture/event-driven.md)

---

**更新时间**: 2024-01-15  
**文档版本**: v1.0  
**负责人**: RedFire架构团队
