"""
Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñËÑöÊú¨
=============

‰∏∫RedFireÈáèÂåñ‰∫§ÊòìÂπ≥Âè∞Êèê‰æõÂÆåÊï¥ÁöÑÊï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂäüËÉΩ
ÂåÖÊã¨Êï∞ÊçÆÂ∫ìÂàõÂª∫„ÄÅË°®ÁªìÊûÑÂàùÂßãÂåñ„ÄÅÁ¥¢ÂºïÂàõÂª∫„ÄÅÊï∞ÊçÆËøÅÁßªÁ≠â
"""

import os
import sys
import asyncio
from typing import Dict, Any, Optional
from datetime import datetime
import logging

from sqlalchemy import create_engine, text, MetaData, Table, Column, Integer, String, DateTime, Float, Boolean, Text
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

from .unified_database_manager import get_database_manager, DatabaseType, DatabaseConfig
from .optimized_config import get_config_manager
from .influxdb_manager import get_influx_manager
from .mongodb_logger import get_mongo_manager
from .read_write_split import get_rw_split_manager

logger = logging.getLogger(__name__)

Base = declarative_base()


class DatabaseInitializer:
    """Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂô®"""
    
    def __init__(self):
        self.db_manager = get_database_manager()
        self.config_manager = get_config_manager()
        self.rw_manager = get_rw_split_manager()
        
        self._initialized_databases = set()
    
    def initialize_all(self) -> bool:
        """ÂàùÂßãÂåñÊâÄÊúâÊï∞ÊçÆÂ∫ì"""
        success = True
        
        try:
            logger.info("ÂºÄÂßãÂàùÂßãÂåñÊï∞ÊçÆÂ∫ìÁ≥ªÁªü...")
            
            # 1. ÂàùÂßãÂåñ‰∏ªÊï∞ÊçÆÂ∫ì (MySQL)
            if self._initialize_mysql():
                logger.info("‚úÖ MySQLÊï∞ÊçÆÂ∫ìÂàùÂßãÂåñÊàêÂäü")
            else:
                logger.error("‚ùå MySQLÊï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂ§±Ë¥•")
                success = False
            
            # 2. ÂàùÂßãÂåñRedisÁºìÂ≠ò
            if self._initialize_redis():
                logger.info("‚úÖ RedisÁºìÂ≠òÂàùÂßãÂåñÊàêÂäü")
            else:
                logger.error("‚ùå RedisÁºìÂ≠òÂàùÂßãÂåñÂ§±Ë¥•")
                success = False
            
            # 3. ÂàùÂßãÂåñInfluxDBÊó∂Â∫èÊï∞ÊçÆÂ∫ì
            if self._initialize_influxdb():
                logger.info("‚úÖ InfluxDBÊó∂Â∫èÊï∞ÊçÆÂ∫ìÂàùÂßãÂåñÊàêÂäü")
            else:
                logger.warning("‚ö†Ô∏è InfluxDBÊó∂Â∫èÊï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂ§±Ë¥•ÔºàÂèØÈÄâÁªÑ‰ª∂Ôºâ")
            
            # 4. ÂàùÂßãÂåñMongoDBÊó•ÂøóÂ≠òÂÇ®
            if self._initialize_mongodb():
                logger.info("‚úÖ MongoDBÊó•ÂøóÂ≠òÂÇ®ÂàùÂßãÂåñÊàêÂäü")
            else:
                logger.warning("‚ö†Ô∏è MongoDBÊó•ÂøóÂ≠òÂÇ®ÂàùÂßãÂåñÂ§±Ë¥•ÔºàÂèØÈÄâÁªÑ‰ª∂Ôºâ")
            
            # 5. ÂàùÂßãÂåñËØªÂÜôÂàÜÁ¶ª
            if self._initialize_read_write_split():
                logger.info("‚úÖ Êï∞ÊçÆÂ∫ìËØªÂÜôÂàÜÁ¶ªÂàùÂßãÂåñÊàêÂäü")
            else:
                logger.warning("‚ö†Ô∏è Êï∞ÊçÆÂ∫ìËØªÂÜôÂàÜÁ¶ªÂàùÂßãÂåñÂ§±Ë¥•")
            
            if success:
                logger.info("üéâ Êï∞ÊçÆÂ∫ìÁ≥ªÁªüÂàùÂßãÂåñÂÆåÊàêÔºÅ")
            else:
                logger.error("üí• Êï∞ÊçÆÂ∫ìÁ≥ªÁªüÂàùÂßãÂåñÂ§±Ë¥•ÔºÅ")
            
            return success
            
        except Exception as e:
            logger.error(f"Êï∞ÊçÆÂ∫ìÁ≥ªÁªüÂàùÂßãÂåñÂºÇÂ∏∏: {e}")
            return False
    
    def _initialize_mysql(self) -> bool:
        """ÂàùÂßãÂåñMySQLÊï∞ÊçÆÂ∫ì"""
        try:
            # ÊµãËØïËøûÊé•
            if not self.config_manager.test_mysql_connection():
                logger.error("MySQLËøûÊé•ÊµãËØïÂ§±Ë¥•")
                return False
            
            # Ëé∑ÂèñÊï∞ÊçÆÂ∫ìËøûÊé•
            pool = self.db_manager.get_pool("main")
            
            # ÂàõÂª∫Êï∞ÊçÆÂ∫ìË°®
            self._create_mysql_tables(pool)
            
            # ÂàõÂª∫Á¥¢Âºï
            self._create_mysql_indexes(pool)
            
            # ÊèíÂÖ•ÂàùÂßãÊï∞ÊçÆ
            self._insert_initial_data(pool)
            
            self._initialized_databases.add("mysql")
            return True
            
        except Exception as e:
            logger.error(f"MySQLÊï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂ§±Ë¥•: {e}")
            return False
    
    def _create_mysql_tables(self, pool):
        """ÂàõÂª∫MySQLÊï∞ÊçÆË°®"""
        try:
            with pool.get_session_factory()() as session:
                # ÂàõÂª∫Áî®Êà∑Ë°®
                session.execute(text("""
                CREATE TABLE IF NOT EXISTS users (
                    id BIGINT AUTO_INCREMENT PRIMARY KEY,
                    username VARCHAR(50) NOT NULL UNIQUE,
                    email VARCHAR(100) NOT NULL UNIQUE,
                    password_hash VARCHAR(255) NOT NULL,
                    is_active BOOLEAN DEFAULT TRUE,
                    is_superuser BOOLEAN DEFAULT FALSE,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    INDEX idx_username (username),
                    INDEX idx_email (email),
                    INDEX idx_created_at (created_at)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                """))
                
                # ÂàõÂª∫‰∫§ÊòìÁ≠ñÁï•Ë°®
                session.execute(text("""
                CREATE TABLE IF NOT EXISTS trading_strategies (
                    id BIGINT AUTO_INCREMENT PRIMARY KEY,
                    user_id BIGINT NOT NULL,
                    name VARCHAR(100) NOT NULL,
                    description TEXT,
                    strategy_type VARCHAR(50) NOT NULL,
                    parameters JSON,
                    is_active BOOLEAN DEFAULT TRUE,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(id),
                    INDEX idx_user_id (user_id),
                    INDEX idx_strategy_type (strategy_type),
                    INDEX idx_is_active (is_active)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                """))
                
                # ÂàõÂª∫‰∫§ÊòìËÆ¢ÂçïË°®
                session.execute(text("""
                CREATE TABLE IF NOT EXISTS trading_orders (
                    id BIGINT AUTO_INCREMENT PRIMARY KEY,
                    user_id BIGINT NOT NULL,
                    strategy_id BIGINT,
                    symbol VARCHAR(20) NOT NULL,
                    side ENUM('BUY', 'SELL') NOT NULL,
                    order_type ENUM('MARKET', 'LIMIT', 'STOP', 'STOP_LIMIT') NOT NULL,
                    quantity DECIMAL(20, 8) NOT NULL,
                    price DECIMAL(20, 8),
                    status ENUM('PENDING', 'PARTIAL', 'FILLED', 'CANCELLED', 'REJECTED') NOT NULL,
                    filled_quantity DECIMAL(20, 8) DEFAULT 0,
                    avg_price DECIMAL(20, 8),
                    commission DECIMAL(20, 8) DEFAULT 0,
                    order_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(id),
                    FOREIGN KEY (strategy_id) REFERENCES trading_strategies(id),
                    INDEX idx_user_id (user_id),
                    INDEX idx_strategy_id (strategy_id),
                    INDEX idx_symbol (symbol),
                    INDEX idx_status (status),
                    INDEX idx_order_time (order_time)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                """))
                
                # ÂàõÂª∫ÊåÅ‰ªìË°®
                session.execute(text("""
                CREATE TABLE IF NOT EXISTS positions (
                    id BIGINT AUTO_INCREMENT PRIMARY KEY,
                    user_id BIGINT NOT NULL,
                    symbol VARCHAR(20) NOT NULL,
                    quantity DECIMAL(20, 8) NOT NULL,
                    avg_price DECIMAL(20, 8) NOT NULL,
                    market_value DECIMAL(20, 2),
                    unrealized_pnl DECIMAL(20, 2),
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(id),
                    UNIQUE KEY uk_user_symbol (user_id, symbol),
                    INDEX idx_user_id (user_id),
                    INDEX idx_symbol (symbol)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                """))
                
                # ÂàõÂª∫Ë¥¶Êà∑ËµÑÈáëË°®
                session.execute(text("""
                CREATE TABLE IF NOT EXISTS account_balance (
                    id BIGINT AUTO_INCREMENT PRIMARY KEY,
                    user_id BIGINT NOT NULL,
                    currency VARCHAR(10) NOT NULL DEFAULT 'CNY',
                    total_balance DECIMAL(20, 2) NOT NULL DEFAULT 0,
                    available_balance DECIMAL(20, 2) NOT NULL DEFAULT 0,
                    frozen_balance DECIMAL(20, 2) NOT NULL DEFAULT 0,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(id),
                    UNIQUE KEY uk_user_currency (user_id, currency),
                    INDEX idx_user_id (user_id)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                """))
                
                session.commit()
                logger.info("MySQLÊï∞ÊçÆË°®ÂàõÂª∫ÂÆåÊàê")
                
        except Exception as e:
            logger.error(f"ÂàõÂª∫MySQLÊï∞ÊçÆË°®Â§±Ë¥•: {e}")
            raise
    
    def _create_mysql_indexes(self, pool):
        """ÂàõÂª∫MySQLÁ¥¢Âºï"""
        try:
            with pool.get_session_factory()() as session:
                # ÂàõÂª∫Â§çÂêàÁ¥¢Âºï
                indexes = [
                    "CREATE INDEX IF NOT EXISTS idx_orders_user_time ON trading_orders(user_id, order_time DESC)",
                    "CREATE INDEX IF NOT EXISTS idx_orders_symbol_time ON trading_orders(symbol, order_time DESC)",
                    "CREATE INDEX IF NOT EXISTS idx_strategies_user_active ON trading_strategies(user_id, is_active)",
                ]
                
                for index_sql in indexes:
                    try:
                        session.execute(text(index_sql))
                    except Exception as e:
                        logger.warning(f"ÂàõÂª∫Á¥¢ÂºïÂ§±Ë¥•: {index_sql}, ÈîôËØØ: {e}")
                
                session.commit()
                logger.info("MySQLÁ¥¢ÂºïÂàõÂª∫ÂÆåÊàê")
                
        except Exception as e:
            logger.error(f"ÂàõÂª∫MySQLÁ¥¢ÂºïÂ§±Ë¥•: {e}")
    
    def _insert_initial_data(self, pool):
        """ÊèíÂÖ•ÂàùÂßãÊï∞ÊçÆ"""
        try:
            with pool.get_session_factory()() as session:
                # Ê£ÄÊü•ÊòØÂê¶Â∑≤ÊúâÁî®Êà∑Êï∞ÊçÆ
                result = session.execute(text("SELECT COUNT(*) FROM users"))
                user_count = result.scalar()
                
                if user_count == 0:
                    # ÊèíÂÖ•ÈªòËÆ§ÁÆ°ÁêÜÂëòÁî®Êà∑
                    from passlib.context import CryptContext
                    pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
                    hashed_password = pwd_context.hash("admin123")
                    
                    session.execute(text("""
                    INSERT INTO users (username, email, password_hash, is_superuser) 
                    VALUES ('admin', 'admin@redfire.com', :password, TRUE)
                    """), {"password": hashed_password})
                    
                    logger.info("ÊèíÂÖ•ÈªòËÆ§ÁÆ°ÁêÜÂëòÁî®Êà∑: admin/admin123")
                
                session.commit()
                
        except Exception as e:
            logger.warning(f"ÊèíÂÖ•ÂàùÂßãÊï∞ÊçÆÂ§±Ë¥•: {e}")
    
    def _initialize_redis(self) -> bool:
        """ÂàùÂßãÂåñRedisÁºìÂ≠ò"""
        try:
            # ÊµãËØïËøûÊé•
            if not self.config_manager.test_redis_connection():
                logger.error("RedisËøûÊé•ÊµãËØïÂ§±Ë¥•")
                return False
            
            # Ê∏ÖÁêÜÊóßÁöÑÁºìÂ≠òÈîÆÔºàÂèØÈÄâÔºâ
            redis_client = self.db_manager.get_redis("cache")
            
            # ËÆæÁΩÆ‰∏Ä‰∫õÈªòËÆ§ÈÖçÁΩÆ
            redis_client.set("redfire:system:initialized", datetime.now().isoformat())
            redis_client.expire("redfire:system:initialized", 86400)  # 24Â∞èÊó∂ËøáÊúü
            
            self._initialized_databases.add("redis")
            return True
            
        except Exception as e:
            logger.error(f"RedisÁºìÂ≠òÂàùÂßãÂåñÂ§±Ë¥•: {e}")
            return False
    
    def _initialize_influxdb(self) -> bool:
        """ÂàùÂßãÂåñInfluxDBÊó∂Â∫èÊï∞ÊçÆÂ∫ì"""
        try:
            # Ê£ÄÊü•InfluxDBÊòØÂê¶ÈÖçÁΩÆ
            if not os.getenv("INFLUX_HOST"):
                logger.info("InfluxDBÊú™ÈÖçÁΩÆÔºåË∑≥ËøáÂàùÂßãÂåñ")
                return True
            
            influx_manager = get_influx_manager()
            
            # ÊµãËØïËøûÊé•
            if not influx_manager.test_connection():
                logger.error("InfluxDBËøûÊé•ÊµãËØïÂ§±Ë¥•")
                return False
            
            # ÂàõÂª∫Á§∫‰æãÊï∞ÊçÆÁÇπÔºàÈ™åËØÅÂÜôÂÖ•ÂäüËÉΩÔºâ
            from .influxdb_manager import TimeSeriesPoint
            test_point = TimeSeriesPoint(
                measurement="system_init",
                fields={"status": 1, "timestamp": datetime.now().timestamp()},
                tags={"source": "database_init"}
            )
            
            if influx_manager.write_point(test_point):
                logger.info("InfluxDBÂÜôÂÖ•ÊµãËØïÊàêÂäü")
            
            self._initialized_databases.add("influxdb")
            return True
            
        except Exception as e:
            logger.error(f"InfluxDBÂàùÂßãÂåñÂ§±Ë¥•: {e}")
            return False
    
    def _initialize_mongodb(self) -> bool:
        """ÂàùÂßãÂåñMongoDBÊó•ÂøóÂ≠òÂÇ®"""
        try:
            # Ê£ÄÊü•MongoDBÊòØÂê¶ÈÖçÁΩÆ
            if not os.getenv("MONGO_HOST"):
                logger.info("MongoDBÊú™ÈÖçÁΩÆÔºåË∑≥ËøáÂàùÂßãÂåñ")
                return True
            
            mongo_manager = get_mongo_manager()
            
            # ÊµãËØïËøûÊé•
            if not mongo_manager.test_sync_connection():
                logger.error("MongoDBËøûÊé•ÊµãËØïÂ§±Ë¥•")
                return False
            
            # ÂàõÂª∫Á¥¢ÂºïÔºàÂºÇÊ≠•Êìç‰ΩúÔºâ
            async def create_indexes():
                await mongo_manager.create_indexes()
            
            # ËøêË°åÂºÇÊ≠•‰ªªÂä°
            try:
                loop = asyncio.get_event_loop()
            except RuntimeError:
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
            
            loop.run_until_complete(create_indexes())
            
            self._initialized_databases.add("mongodb")
            return True
            
        except Exception as e:
            logger.error(f"MongoDBÂàùÂßãÂåñÂ§±Ë¥•: {e}")
            return False
    
    def _initialize_read_write_split(self) -> bool:
        """ÂàùÂßãÂåñËØªÂÜôÂàÜÁ¶ª"""
        try:
            # ÊµãËØïËØªÂÜôËäÇÁÇπ
            stats = self.rw_manager.get_all_stats()
            
            healthy_masters = stats.get("healthy_master_nodes", 0)
            total_masters = stats.get("total_master_nodes", 0)
            
            if healthy_masters == 0:
                logger.error("Ê≤°ÊúâÂÅ•Â∫∑ÁöÑ‰∏ªÊï∞ÊçÆÂ∫ìËäÇÁÇπ")
                return False
            
            logger.info(f"‰∏ªËäÇÁÇπÁä∂ÊÄÅ: {healthy_masters}/{total_masters} ÂÅ•Â∫∑")
            
            if stats.get("total_slave_nodes", 0) > 0:
                healthy_slaves = stats.get("healthy_slave_nodes", 0)
                total_slaves = stats.get("total_slave_nodes", 0)
                logger.info(f"‰ªéËäÇÁÇπÁä∂ÊÄÅ: {healthy_slaves}/{total_slaves} ÂÅ•Â∫∑")
            else:
                logger.info("Êú™ÈÖçÁΩÆ‰ªéËäÇÁÇπÔºåËØªÂÜôÊìç‰ΩúÂ∞Ü‰ΩøÁî®‰∏ªËäÇÁÇπ")
            
            self._initialized_databases.add("read_write_split")
            return True
            
        except Exception as e:
            logger.error(f"ËØªÂÜôÂàÜÁ¶ªÂàùÂßãÂåñÂ§±Ë¥•: {e}")
            return False
    
    def get_initialization_status(self) -> Dict[str, Any]:
        """Ëé∑ÂèñÂàùÂßãÂåñÁä∂ÊÄÅ"""
        status = {
            "initialized_databases": list(self._initialized_databases),
            "mysql": "mysql" in self._initialized_databases,
            "redis": "redis" in self._initialized_databases,
            "influxdb": "influxdb" in self._initialized_databases,
            "mongodb": "mongodb" in self._initialized_databases,
            "read_write_split": "read_write_split" in self._initialized_databases,
            "initialization_time": datetime.now().isoformat()
        }
        
        # Ê∑ªÂä†ËøûÊé•ÁªüËÆ°
        try:
            status["database_stats"] = self.db_manager.get_all_stats()
        except Exception as e:
            logger.warning(f"Ëé∑ÂèñÊï∞ÊçÆÂ∫ìÁªüËÆ°Â§±Ë¥•: {e}")
        
        try:
            status["rw_split_stats"] = self.rw_manager.get_all_stats()
        except Exception as e:
            logger.warning(f"Ëé∑ÂèñËØªÂÜôÂàÜÁ¶ªÁªüËÆ°Â§±Ë¥•: {e}")
        
        return status
    
    def cleanup(self):
        """Ê∏ÖÁêÜËµÑÊ∫ê"""
        try:
            self.db_manager.close_all()
            self.rw_manager.close_all()
            logger.info("Êï∞ÊçÆÂ∫ìËµÑÊ∫êÊ∏ÖÁêÜÂÆåÊàê")
        except Exception as e:
            logger.error(f"Êï∞ÊçÆÂ∫ìËµÑÊ∫êÊ∏ÖÁêÜÂ§±Ë¥•: {e}")


def initialize_databases() -> bool:
    """ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ìÁ≥ªÁªü"""
    initializer = DatabaseInitializer()
    return initializer.initialize_all()


def get_database_status() -> Dict[str, Any]:
    """Ëé∑ÂèñÊï∞ÊçÆÂ∫ìÁä∂ÊÄÅ"""
    initializer = DatabaseInitializer()
    return initializer.get_initialization_status()


if __name__ == "__main__":
    # ËÆæÁΩÆÊó•Âøó
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ì
    success = initialize_databases()
    
    if success:
        print("‚úÖ Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñÊàêÂäüÔºÅ")
        sys.exit(0)
    else:
        print("‚ùå Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂ§±Ë¥•ÔºÅ")
        sys.exit(1)
